<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analyseur d'Ouvertures Chess.com</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/cm-chessboard@7.11.0/assets/chessboard.css"
  />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5em;
    }

    .subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 30px;
    }

    .mode-toggle {
      display: inline-flex;
      gap: 10px;
      margin-bottom: 18px;
      background: #eef2ff;
      padding: 6px;
      border-radius: 999px;
    }

    .mode-btn {
      border: none;
      background: transparent;
      color: #4c51bf;
      font-weight: 600;
      padding: 10px 18px;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s, transform 0.2s;
    }

    .mode-btn.is-active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      box-shadow: 0 10px 24px rgba(102, 126, 234, 0.35);
    }

    .mode-btn:hover {
      transform: translateY(-1px);
    }

    .search-section {
      display: grid;
      gap: 16px;
      margin-bottom: 30px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      align-items: end;
    }

    .control-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .toggle-field {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 14px;
    }

    .toggle-field.is-disabled {
      opacity: 0.6;
    }

    .toggle-field.is-disabled input:not([type="checkbox"]),
    .toggle-field.is-disabled select {
      cursor: not-allowed;
    }

    .control-label {
      font-size: 14px;
      font-weight: 600;
      color: #4c51bf;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .engine-toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: #374151;
    }

    .engine-toggle input[type="checkbox"] {
      transform: scale(1.2);
    }

    .engine-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
      gap: 8px;
      margin-top: 10px;
    }

    .engine-option {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .engine-option label {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      color: #64748b;
      letter-spacing: 0.05em;
    }

    input[type="text"],
    input[type="number"],
    select {
      padding: 14px 15px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 16px;
      transition: border-color 0.3s, box-shadow 0.3s;
      min-width: 0;
      width: 100%;
      background: white;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
    }

    button {
      padding: 15px 30px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .primary-action {
      align-self: stretch;
      min-height: 54px;
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .secondary-button {
      background: white;
      color: #4c51bf;
      border: 2px solid rgba(102, 126, 234, 0.4);
      box-shadow: none;
    }

    .secondary-button:hover {
      background: #eef2ff;
      box-shadow: 0 5px 16px rgba(102, 126, 234, 0.25);
    }

    .prep-actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin: 12px 0 24px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .badge-trap {
      background: #fef2f2;
      color: #b91c1c;
      border: 1px solid #fecaca;
    }

    .badge-gm {
      background: #ecfdf5;
      color: #047857;
      border: 1px solid #bbf7d0;
    }

    .badge-improve {
      background: #eff6ff;
      color: #1d4ed8;
      border: 1px solid #bfdbfe;
    }

    .gm-section,
    .improvement-section {
      margin-top: 16px;
      padding: 12px;
      border-radius: 12px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
    }

    .gm-entry + .gm-entry,
    .improvement-entry + .improvement-entry {
      margin-top: 12px;
    }

    .gm-entry-title,
    .improvement-entry-title {
      font-weight: 600;
      color: #1f2937;
      margin-bottom: 4px;
    }

    .gm-meta,
    .improvement-meta {
      font-size: 0.85rem;
      color: #4b5563;
    }

    .gm-reco,
    .improvement-reco {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .source-tag {
      font-size: 12px;
      color: #4c51bf;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .delta-positive {
      color: #047857;
      font-weight: 600;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .loading {
      text-align: center;
      padding: 20px;
      font-size: 18px;
      color: #667eea;
    }

    .error {
      background: #fee;
      color: #c00;
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
    }

    .player-info {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
    }

    .player-info h2 {
      color: #333;
      margin-bottom: 10px;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .stat-card {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .stat-label {
      color: #666;
      font-size: 14px;
    }

    .stat-value {
      color: #333;
      font-size: 24px;
      font-weight: bold;
      margin-top: 5px;
    }

    .openings-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-top: 30px;
    }

    @media (max-width: 768px) {
      .openings-section {
        grid-template-columns: 1fr;
      }
    }

    .openings-card {
      background: #f8f9fa;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    }

    .openings-card h3 {
      margin-bottom: 20px;
      color: #333;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .chess-piece {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .white-piece {
      background: white;
      border: 2px solid #333;
    }

    .black-piece {
      background: #333;
      color: white;
    }

    .opening-item {
      background: white;
      padding: 15px;
      margin-bottom: 10px;
      border-radius: 8px;
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }

    .opening-item:hover {
      transform: translateX(5px);
      box-shadow: 0 3px 15px rgba(0, 0, 0, 0.1);
    }

    .opening-name {
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }

    .trap-name {
      color: #c00;
      font-weight: bold;
    }

    .trap-name::before {
      content: '☠️';
      margin-right: 5px;
    }

    .opening-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .opening-stat {
      font-size: 14px;
      color: #666;
    }

    .win-rate {
      color: #28a745;
      font-weight: bold;
    }

    .draw-rate {
      color: #ffc107;
      font-weight: bold;
    }

    .loss-rate {
      color: #dc3545;
      font-weight: bold;
    }

    .progress-bar {
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      margin-top: 8px;
      overflow: hidden;
      display: flex;
    }

    .progress-win {
      background: #28a745;
      height: 100%;
      transition: width 0.3s;
    }

    .progress-draw {
      background: #ffc107;
      height: 100%;
      transition: width 0.3s;
    }

    .progress-loss {
      background: #dc3545;
      height: 100%;
      transition: width 0.3s;
    }

    .no-data {
      text-align: center;
      color: #999;
      padding: 20px;
      font-style: italic;
    }

    .trap-name {
      color: #b10000;
      font-weight: 700;
    }

    .trap-recos {
      margin-top: .4rem;
      border-left: 3px solid #b10000;
      padding-left: .6rem;
    }

    .trap-reco {
      margin: .25rem 0;
      font-size: .92rem;
    }

    .trap-reco-seq {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      opacity: .9;
    }

    .trap-reco-tip {
      opacity: .85;
    }
    .line-block {
      margin-top: 12px;
    }
    .line-label {
      font-weight: 600;
      color: #444;
      margin-bottom: 4px;
    }
    .line-preview {
      display: block;
      width: 100%;
      text-align: left;
      background: #eef2ff;
      border: none;
      border-radius: 8px;
      padding: 10px 12px;
      font-size: .95rem;
      cursor: pointer;
      white-space: normal;
      line-height: 1.5;
      transition: background .2s, transform .2s;
    }
    .line-preview:hover {
      background: #e0e7ff;
      transform: translateX(2px);
    }
    .line-preview:focus {
      outline: 2px solid #667eea;
      outline-offset: 2px;
    }
    .line-meta {
      margin-top: 6px;
      font-size: .85rem;
      color: #555;
    }
    .observed-traps {
      margin-top: 16px;
      padding: 12px;
      border-radius: 12px;
      background: #fff5f5;
      border: 1px solid #f5c2c7;
    }
    .observed-traps-header {
      font-weight: 700;
      color: #b10000;
      margin-bottom: 8px;
    }
    .observed-trap + .observed-trap {
      margin-top: 12px;
    }
    .trap-detected-name {
      font-weight: 600;
      color: #b10000;
      margin-bottom: 6px;
    }
    .trap-reco-line {
      margin-top: 6px;
    }
    .lichess-advice {
      margin-top: .5rem;
      border-left: 3px solid #667eea;
      padding-left: .6rem;
      font-size: .9rem;
    }
    .lichess-advice summary {
      cursor: pointer;
      font-weight: 600;
      padding: .2rem 0;
    }
    .lichess-advice ul {
      list-style-type: none;
      padding-left: .2rem;
      margin-top: .4rem;
    }
    .lichess-advice li {
      margin-bottom: .3rem;
      display: flex;
      flex-direction: column;
      gap: .25rem;
    }
    #boardPreview {
      position: absolute;
      display: none;
      z-index: 1000;
      background: white;
      border-radius: 12px;
      box-shadow: 0 15px 45px rgba(0, 0, 0, 0.25);
      padding: 12px;
      pointer-events: none;
      width: 240px;
    }
    #boardPreview .board-preview-board {
      width: 216px;
      height: 216px;
    }
    .board-preview-caption {
      margin-top: 8px;
      font-size: .8rem;
      color: #444;
      line-height: 1.35;
      word-break: break-word;
    }
    .line-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      background: rgba(15, 23, 42, 0.55);
      z-index: 2000;
    }
    .line-modal.is-open {
      display: flex;
    }
    body.modal-open {
      overflow: hidden;
    }
    .line-modal-dialog {
      background: #fff;
      border-radius: 18px;
      width: min(900px, 100%);
      max-height: 90vh;
      box-shadow: 0 25px 70px rgba(15, 23, 42, 0.35);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .line-modal-header {
      padding: 18px 24px;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .line-modal-title {
      font-size: 1.1rem;
      font-weight: 600;
      color: #1f2937;
    }
    .line-modal-close {
      background: none;
      border: none;
      font-size: 1.6rem;
      line-height: 1;
      cursor: pointer;
      color: #6b7280;
      padding: 4px;
      border-radius: 6px;
      transition: background .2s, color .2s;
    }
    .line-modal-close:hover {
      background: rgba(102, 126, 234, 0.12);
      color: #4c51bf;
    }
    .line-modal-content {
      display: flex;
      gap: 24px;
      padding: 24px;
      flex-wrap: wrap;
      overflow-y: auto;
    }
    .line-modal-board {
      flex: none;
      width: min(360px, 100%);
      aspect-ratio: 1;
      border-radius: 16px;
      box-shadow: inset 0 0 0 1px rgba(99, 102, 241, 0.12);
      overflow: hidden;
    }
    .line-modal-sidebar {
      flex: 1;
      min-width: min(320px, 100%);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .line-modal-subtitle {
      color: #4b5563;
      font-size: .95rem;
      line-height: 1.4;
    }
    .line-modal-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .line-modal-controls button {
      flex: none;
      min-width: 48px;
      padding: 10px 14px;
      border-radius: 8px;
      border: none;
      background: #eef2ff;
      color: #3730a3;
      font-weight: 600;
      cursor: pointer;
      transition: background .2s, transform .2s;
    }
    .line-modal-controls button:hover {
      background: #e0e7ff;
      transform: translateY(-1px);
    }
    .line-modal-controls button:disabled {
      opacity: .6;
      cursor: not-allowed;
      transform: none;
    }
    .line-modal-moves {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
      padding-right: 4px;
    }
    .move-chip {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      background: #f3f4f6;
      color: #1f2937;
      font-size: .9rem;
      cursor: pointer;
      transition: background .2s, color .2s, transform .2s;
    }
    .move-chip:hover {
      background: #e0e7ff;
      color: #3730a3;
      transform: translateY(-1px);
    }
    .move-chip.is-active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.35);
    }
    .move-chip.is-past:not(.is-active) {
      background: #e0e7ff;
      color: #4338ca;
    }
    .line-modal-footer {
      padding: 0 24px 24px;
    }
    .line-modal-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      text-decoration: none;
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
      transition: transform .2s, box-shadow .2s;
    }
    .line-modal-link:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 24px rgba(102, 126, 234, 0.35);
    }
    @media (max-width: 640px) {
      .line-modal-dialog {
        max-height: none;
        height: 100%;
        border-radius: 0;
      }
      .line-modal-content {
        flex-direction: column;
        padding: 20px;
      }
      .line-modal-board {
        width: 100%;
      }
      .line-modal-sidebar {
        min-width: 100%;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>♟️ Analyseur d'Ouvertures Chess.com</h1>
    <p class="subtitle">Découvrez les ouvertures préférées de n'importe quel joueur</p>

    <div class="mode-toggle" role="tablist" aria-label="Mode d'analyse">
      <button type="button" class="mode-btn is-active" data-mode="opponent" id="modeOpponent" aria-pressed="true">
        Analyser un adversaire
      </button>
      <button type="button" class="mode-btn" data-mode="self" id="modeSelf" aria-pressed="false">
        M'analyser moi
      </button>
    </div>

    <div class="search-section" id="controlPanel">
      <div class="control-field">
        <label class="control-label" for="username">Pseudo Chess.com</label>
        <input
          type="text"
          id="username"
          placeholder="Entrez le pseudo Chess.com (ex: hikaru)"
          autocomplete="username"
        />
      </div>
      <div class="control-field">
        <label class="control-label" for="speedSelect">Cadence cible</label>
        <select id="speedSelect">
          <option value="auto">Auto (selon stats)</option>
          <option value="bullet">Bullet</option>
          <option value="blitz">Blitz</option>
          <option value="rapid">Rapid</option>
          <option value="classical">Classical</option>
          <option value="correspondence">Correspondence</option>
        </select>
      </div>
      <div class="control-field">
        <label class="control-label" for="ratingOffset">Décalage Elo Explorer</label>
        <input type="number" id="ratingOffset" value="0" step="50" />
      </div>
      <div class="control-field">
        <label class="control-label" for="gmMode">Théorie GM</label>
        <select id="gmMode">
          <option value="top1">Top 1</option>
          <option value="topK">Top K</option>
          <option value="coverage">Couverture %</option>
        </select>
      </div>
      <div class="control-field" id="gmTopKField" style="display: none;">
        <label class="control-label" for="gmTopK">K (Top K)</label>
        <input type="number" id="gmTopK" min="1" max="6" value="3" />
      </div>
      <div class="control-field" id="gmCoverageField" style="display: none;">
        <label class="control-label" for="gmCoverage">Couverture minimale (%)</label>
        <input type="number" id="gmCoverage" min="10" max="100" value="70" step="5" />
      </div>
      <div class="control-field">
        <label class="control-label" for="minMasterGames">Volume Masters minimum</label>
        <input type="number" id="minMasterGames" min="10" max="500" step="10" value="50" />
      </div>
      <div class="control-field toggle-field" id="engineSettings">
        <span class="control-label">Moteur local</span>
        <label class="engine-toggle" for="engineEnabled">
          <input type="checkbox" id="engineEnabled" />
          <span>Activer Stockfish local</span>
        </label>
        <input
          type="text"
          id="enginePath"
          placeholder="Chemin Worker Stockfish (optionnel)"
          autocomplete="off"
        />
        <div class="engine-options">
          <div class="engine-option">
            <label for="engineDepth">Profondeur</label>
            <input type="number" id="engineDepth" min="6" max="30" value="18" />
          </div>
          <div class="engine-option">
            <label for="engineMultiPv">MultiPV</label>
            <input type="number" id="engineMultiPv" min="1" max="5" value="3" />
          </div>
        </div>
      </div>
      <button id="analyzeBtn" class="primary-action">Lancer l'analyse</button>
    </div>

    <div id="loading" class="loading" style="display: none;">
      ⏳ Chargement des parties en cours...
    </div>

    <div id="error" class="error" style="display: none;"></div>

    <div id="playerInfo" style="display: none;"></div>

    <div id="prepActions" class="prep-actions" style="display: none;">
      <button type="button" id="exportJsonBtn" class="secondary-button">Export JSON</button>
      <button type="button" id="exportMarkdownBtn" class="secondary-button">Export Markdown</button>
      <button type="button" id="exportPdfBtn" class="secondary-button">PDF imprimable</button>
    </div>

    <div id="openingsSection" class="openings-section" style="display: none;">
      <div class="openings-card">
        <h3>
          <span class="chess-piece white-piece">♔</span>
          Ouvertures avec les Blancs
        </h3>
        <div id="whiteOpenings"></div>
      </div>

      <div class="openings-card">
        <h3>
          <span class="chess-piece black-piece">♚</span>
          Ouvertures avec les Noirs
        </h3>
        <div id="blackOpenings"></div>
      </div>
    </div>
  </div>

  <div id="boardPreview">
    <div
      id="boardPreviewBoard"
      class="board-preview-board"
      aria-hidden="true"
    ></div>
    <div class="board-preview-caption" id="boardPreviewCaption"></div>
  </div>

  <div
    id="lineModal"
    class="line-modal"
    role="dialog"
    aria-modal="true"
    aria-hidden="true"
  >
    <div class="line-modal-dialog">
      <div class="line-modal-header">
        <div class="line-modal-title" id="lineModalTitle">Séquence</div>
        <button
          type="button"
          class="line-modal-close"
          id="lineModalClose"
          aria-label="Fermer"
        >
          ×
        </button>
      </div>
      <div class="line-modal-content">
        <div class="line-modal-board" id="lineModalBoard" aria-hidden="false"></div>
        <div class="line-modal-sidebar">
          <div class="line-modal-subtitle" id="lineModalSummary"></div>
          <div class="line-modal-controls">
            <button type="button" id="lineModalStart">⏮ Début</button>
            <button type="button" id="lineModalPrev">◀️ Précédent</button>
            <button type="button" id="lineModalNext">▶️ Suivant</button>
            <button type="button" id="lineModalEnd">⏭ Fin</button>
          </div>
          <div class="line-modal-moves" id="lineModalMoves"></div>
        </div>
      </div>
      <div class="line-modal-footer">
        <a
          href="https://lichess.org/analysis"
          target="_blank"
          rel="noopener"
          id="lineModalLichess"
          class="line-modal-link"
        >
          ↗ Voir la position sur Lichess
        </a>
      </div>
    </div>
  </div>

  <script type="module">
    import { Chess } from 'https://esm.sh/chess.js';
    import {
      Chessboard,
      BORDER_TYPE,
      FEN,
    } from 'https://unpkg.com/cm-chessboard@7.11.0/src/Chessboard.js';
    import {
      adviseFromLichess,
      detectGmDeviationsFromPgn,
      fetchExplorer,
      pickLichessBucket,
      scoreMoves,
    } from './lichess-explorer.js';
    import { registerEcoOpenings } from './eco-pack-xl.js';
    import { TrapEngine, TRAP_PACK } from './trap-engine.js';

    class EngineManager {
      constructor() {
        this.worker = null;
        this.currentPath = null;
        this.ready = false;
        this.options = {};
        this.pendingEval = null;
        this.currentFen = null;
        this.resolveReady = null;
        this.rejectReady = null;
      }

      dispose() {
        if (this.pendingEval) {
          clearTimeout(this.pendingEval.timeoutId);
          try {
            this.pendingEval.resolve(null);
          } catch {}
          this.pendingEval = null;
        }
        if (this.worker) {
          try {
            this.worker.terminate();
          } catch {}
        }
        this.worker = null;
        this.currentPath = null;
        this.ready = false;
        this.currentFen = null;
        this.resolveReady = null;
        this.rejectReady = null;
      }

      async configure(config = {}) {
        this.options = config;
        if (!config.enabled || !config.path) {
          this.dispose();
          return;
        }
        if (this.worker && this.currentPath === config.path) {
          try {
            await this.waitUntilReady(2500).catch(() => {});
          } catch {}
          return;
        }

        this.dispose();
        try {
          this.worker = new Worker(config.path);
        } catch (err) {
          console.warn('Impossible d\'initialiser le moteur local:', err);
          this.worker = null;
          return;
        }

        this.currentPath = config.path;
        this.ready = false;
        this.worker.onmessage = (event) => this.handleMessage(event.data);
        this.worker.onerror = (event) => {
          console.warn('Erreur moteur:', event.message || event);
          this.ready = false;
        };
        this.sendCommand('uci');

        try {
          await this.waitUntilReady(4000);
        } catch (err) {
          console.warn('Le moteur ne répond pas:', err?.message || err);
        }

        if (this.ready) {
          const multipv = Math.max(1, Math.min(5, Number(config.multipv) || 1));
          this.sendCommand(`setoption name MultiPV value ${multipv}`);
          if (config.threads) {
            this.sendCommand(`setoption name Threads value ${config.threads}`);
          }
        }
      }

      sendCommand(command) {
        if (!this.worker || !command) return;
        try {
          this.worker.postMessage(command);
        } catch (err) {
          console.warn('Commande moteur rejetée', command, err);
        }
      }

      handleMessage(message) {
        if (message == null) return;
        if (typeof message === 'string') {
          this.handleMessageString(message);
        } else if (typeof message === 'object') {
          if (message.type === 'info' && message.message) {
            this.handleInfo(String(message.message));
          } else if (message.type === 'bestmove' && message.message) {
            this.handleBestmove(String(message.message));
          } else if (typeof message.message === 'string') {
            this.handleMessageString(message.message);
          }
        }
      }

      handleMessageString(line) {
        const text = String(line || '').trim();
        if (!text) return;
        if (text === 'uciok') {
          this.sendCommand('isready');
          return;
        }
        if (text === 'readyok') {
          this.ready = true;
          if (this.resolveReady) {
            this.resolveReady();
            this.resolveReady = null;
            this.rejectReady = null;
          }
          return;
        }
        if (text.startsWith('info ')) {
          this.handleInfo(text);
          return;
        }
        if (text.startsWith('bestmove')) {
          this.handleBestmove(text);
        }
      }

      handleInfo(line) {
        if (!this.pendingEval) return;
        const parsed = this.parseInfoLine(line);
        if (!parsed) return;
        this.pendingEval.lines.set(parsed.multipv, parsed);
      }

      handleBestmove(line) {
        if (!this.pendingEval) return;
        clearTimeout(this.pendingEval.timeoutId);
        const parts = String(line).trim().split(/\s+/);
        const bestmove = parts[1] || '';
        const lines = Array.from(this.pendingEval.lines.values())
          .sort((a, b) => a.multipv - b.multipv)
          .map((entry) => ({
            multipv: entry.multipv,
            score: entry.score,
            pvSan: entry.pvSan,
            pvUci: entry.pvUci,
          }));
        const payload = { bestmove, lines };
        try {
          this.pendingEval.resolve(lines.length ? payload : null);
        } catch {}
        this.pendingEval = null;
      }

      waitUntilReady(timeout = 3000) {
        if (this.ready) return Promise.resolve(true);
        return new Promise((resolve, reject) => {
          if (!this.worker) {
            reject(new Error('Moteur non initialisé'));
            return;
          }
          const timer = setTimeout(() => {
            this.resolveReady = null;
            this.rejectReady = null;
            reject(new Error('Timeout moteur'));
          }, timeout);
          this.resolveReady = () => {
            clearTimeout(timer);
            resolve(true);
          };
          this.rejectReady = (err) => {
            clearTimeout(timer);
            reject(err);
          };
          this.sendCommand('isready');
        });
      }

      async evaluateFen(fen, options = {}) {
        if (!this.worker) return null;
        if (!this.ready) {
          try {
            await this.waitUntilReady(3000);
          } catch (err) {
            console.warn('Moteur indisponible:', err?.message || err);
            return null;
          }
        }

        return new Promise((resolve) => {
          if (!this.worker) {
            resolve(null);
            return;
          }

          if (this.pendingEval) {
            clearTimeout(this.pendingEval.timeoutId);
            try {
              this.pendingEval.resolve(null);
            } catch {}
            this.pendingEval = null;
          }

          this.currentFen = fen;
          const evaluation = {
            resolve,
            lines: new Map(),
            timeoutId: null,
          };
          this.pendingEval = evaluation;

          this.sendCommand('stop');
          this.sendCommand('ucinewgame');
          this.sendCommand(`position fen ${fen}`);

          const goCommand = this.buildGoCommand(options || this.options || {});
          this.sendCommand(goCommand);

          const timeoutMs = options.timeoutMs || 6000;
          evaluation.timeoutId = setTimeout(() => {
            this.sendCommand('stop');
            if (this.pendingEval === evaluation) {
              this.pendingEval = null;
              resolve(null);
            }
          }, timeoutMs);
        });
      }

      buildGoCommand(options) {
        const parts = ['go'];
        if (options.movetime) {
          parts.push('movetime', Number(options.movetime));
        } else if (options.depth) {
          parts.push('depth', Number(options.depth));
        } else if (this.options.depth) {
          parts.push('depth', Number(this.options.depth));
        } else {
          parts.push('depth', 18);
        }
        if (options.nodes) {
          parts.push('nodes', Number(options.nodes));
        }
        if (options.multipv || this.options.multipv) {
          const v = Number(options.multipv || this.options.multipv);
          if (v > 1) parts.push('multipv', Math.max(1, Math.min(5, v)));
        }
        return parts.join(' ');
      }

      parseInfoLine(line) {
        const parts = String(line).trim().split(/\s+/);
        let multipv = 1;
        let scoreType = null;
        let scoreValue = null;
        let pvIndex = parts.indexOf('pv');
        for (let i = 0; i < parts.length; i++) {
          const token = parts[i];
          if (token === 'multipv' && i + 1 < parts.length) {
            const value = Number(parts[i + 1]);
            if (Number.isFinite(value)) multipv = value;
          }
          if (token === 'score' && i + 2 < parts.length) {
            scoreType = parts[i + 1];
            scoreValue = Number(parts[i + 2]);
          }
        }
        const pvUci = pvIndex >= 0 ? parts.slice(pvIndex + 1) : [];
        const pvSan = this.convertPvToSan(pvUci);
        if (!pvSan.length && !pvUci.length) return null;
        const score = scoreType ? { type: scoreType, value: scoreValue } : null;
        return { multipv, score, pvSan, pvUci };
      }

      convertPvToSan(pvMoves) {
        if (!pvMoves?.length || !this.currentFen) return pvMoves || [];
        const chess = new Chess();
        try {
          const ok = chess.load(this.currentFen);
          if (!ok) return pvMoves;
        } catch (err) {
          return pvMoves;
        }
        const out = [];
        for (const move of pvMoves) {
          if (!move) break;
          const from = move.slice(0, 2);
          const to = move.slice(2, 4);
          const promotion = move.length > 4 ? move.slice(4) : undefined;
          const played = chess.move({ from, to, promotion }, { sloppy: true });
          if (!played) break;
          out.push(played.san);
        }
        return out.length ? out : pvMoves;
      }
    }

    // ------------ ECO MAP DE BASE + PACK XL ------------
    const ECO_OPENINGS = new Map([
      [['e4', 'e5', 'Nf3', 'Nc6', 'Bb5'].join(' '), 'Espagnole (Ruy Lopez)'],
      [['e4', 'e5', 'Nf3', 'Nc6', 'Bc4'].join(' '), 'Italienne (Giuoco Piano)'],
      [['e4', 'e5', 'Nf3', 'Nf6'].join(' '), 'Défense Petrov'],
      [['e4', 'e5', 'Nf3', 'Nc6', 'd4'].join(' '), 'Écossaise'],
      [['e4', 'e5', 'Nf3', 'f5'].join(' '), 'Gambit Letton'],
      [['e4', 'e5', 'f4'].join(' '), 'Gambit du Roi'],
      [['e4', 'e5', 'Nc3'].join(' '), 'Viennoise'],
      [['e4', 'e5', 'Bc4'].join(' '), 'Partie du Fou'],

      // Sicilienne
      [['e4', 'c5'].join(' '), 'Défense Sicilienne'],
      [['e4', 'c5', 'Nf3', 'd6'].join(' '), 'Sicilienne Dragon (setup)'],
      [['e4', 'c5', 'Nf3', 'Nc6'].join(' '), 'Sicilienne Classique'],
      [['e4', 'c5', 'Nf3', 'e6'].join(' '), 'Sicilienne Variante Française'],
      [['e4', 'c5', 'Nf3', 'Nf6'].join(' '), 'Sicilienne Nimzowitsch'],
      [['e4', 'c5', 'c3'].join(' '), 'Sicilienne Alapin'],

      // Française
      [['e4', 'e6'].join(' '), 'Défense Française'],
      [['e4', 'e6', 'd4', 'd5'].join(' '), 'Française (Var. principale)'],
      [['e4', 'e6', 'd4', 'd5', 'e5'].join(' '), 'Française Avance'],
      [['e4', 'e6', 'd4', 'd5', 'Nc3'].join(' '), 'Française Classique'],
      [['e4', 'e6', 'd4', 'd5', 'exd5'].join(' '), 'Française Échange'],

      // Caro-Kann
      [['e4', 'c6'].join(' '), 'Défense Caro-Kann'],
      [['e4', 'c6', 'd4', 'd5'].join(' '), 'Caro-Kann (Var. principale)'],
      [['e4', 'c6', 'd4', 'd5', 'Nc3'].join(' '), 'Caro-Kann Classique'],
      [['e4', 'c6', 'd4', 'd5', 'e5'].join(' '), 'Caro-Kann Avance'],

      // Autres vs e4
      [['e4', 'd5'].join(' '), 'Défense Scandinave'],
      [['e4', 'd6'].join(' '), 'Défense Pirc'],
      [['e4', 'Nf6'].join(' '), 'Défense Alekhine'],
      [['e4', 'g6'].join(' '), 'Défense Moderne'],
      [['e4', 'Nc6'].join(' '), 'Défense Nimzowitsch'],
      [['e4', 'a6'].join(' '), 'Défense St. George'],
      [['e4', 'b6'].join(' '), 'Défense Owen'],

      // d4
      [['d4', 'd5'].join(' '), 'Partie du Pion Dame'],
      [['d4', 'd5', 'c4'].join(' '), 'Gambit Dame'],
      [['d4', 'd5', 'c4', 'dxc4'].join(' '), 'Gambit Dame Accepté'],
      [['d4', 'd5', 'c4', 'e6'].join(' '), 'Gambit Dame Refusé'],
      [['d4', 'd5', 'c4', 'c6'].join(' '), 'Défense Slave'],
      [['d4', 'd5', 'Nf3'].join(' '), 'Système de Londres (ordre flexible)'],
      [['d4', 'd5', 'Bf4'].join(' '), 'Système de Londres (avec Bf4)'],

      // Indiennes
      [['d4', 'Nf6'].join(' '), 'Défenses Indiennes'],
      [['d4', 'Nf6', 'c4', 'e6'].join(' '), 'Nimzo/Ouest-Indienne (set-up)'],
      [['d4', 'Nf6', 'c4', 'g6'].join(' '), 'Est-Indienne (set-up)'],
      [['d4', 'Nf6', 'c4', 'e6', 'Nc3', 'Bb4'].join(' '), 'Défense Nimzo-Indienne'],
      [['d4', 'Nf6', 'c4', 'e6', 'Nf3', 'b6'].join(' '), 'Défense Ouest-Indienne'],
      [['d4', 'Nf6', 'c4', 'c5'].join(' '), 'Défense Benoni Moderne'],
      [['d4', 'Nf6', 'Nf3', 'g6'].join(' '), 'Est-Indienne (avec Nf3)'],

      // Autres d4
      [['d4', 'f5'].join(' '), 'Défense Hollandaise'],
      [['d4', 'e6'].join(' '), 'Française par transposition'],
      [['d4', 'g6'].join(' '), 'Moderne vs d4'],
      [['d4', 'd6'].join(' '), 'Old Indian'],
      [['d4', 'c5'].join(' '), 'Benoni Ancienne'],

      // Anglaise, Réti et co
      [['c4'].join(' '), 'Ouverture Anglaise'],
      [['c4', 'e5'].join(' '), 'Anglaise Symétrique (réponse e5)'],
      [['c4', 'c5'].join(' '), 'Anglaise Symétrique (Sicilienne inversée)'],
      [['c4', 'Nf6'].join(' '), 'Anglaise avec Nf6'],
      [['c4', 'e6'].join(' '), 'Anglaise avec e6'],

      [['Nf3'].join(' '), 'Ouverture Réti'],
      [['Nf3', 'd5'].join(' '), 'Réti avec d5'],
      [['Nf3', 'Nf6'].join(' '), 'Réti Symétrique'],
      [['Nf3', 'd5', 'c4'].join(' '), 'Gambit Réti'],

      [['f4'].join(' '), 'Ouverture Bird'],
      [['b3'].join(' '), 'Ouverture Larsen'],
      [['g3'].join(' '), 'Ouverture Benko (fianchetto)'],
      [['Nc3'].join(' '), 'Ouverture Van Geet'],
      [['e3'].join(' '), "Ouverture Van't Kruijs"],
      [['b4'].join(' '), 'Ouverture Polonaise'],
    ]);

    // Injecte le pack XL + pièges
    registerEcoOpenings(ECO_OPENINGS, { includeTraps: true });

    const trapEngine = new TrapEngine();
    trapEngine.register(TRAP_PACK);

    const engineManager = new EngineManager();

    const ANALYSIS_MODES = {
      opponent: 'opponent',
      self: 'self',
    };

    const state = {
      mode: ANALYSIS_MODES.opponent,
      latestPrep: null,
      latestPlayer: null,
      speed: 'blitz',
      ratingBucket: null,
      config: null,
    };

    // ------------ FALLBACK 1er COUP ------------
    const FIRST_MOVE_FALLBACK = new Map([
      ['e4', 'Ouvertures ouvertes (1.e4)'],
      ['d4', 'Ouvertures fermées (1.d4)'],
      ['c4', 'Ouverture Anglaise'],
      ['Nf3', 'Ouverture Réti'],
      ['f4', 'Ouverture Bird'],
      ['b3', 'Ouverture Larsen'],
      ['g3', 'Fianchetto (type Réti/Anglaise)'],
      ['Nc3', 'Ouverture Van Geet'],
      ['e3', "Ouverture Van't Kruijs"],
      ['b4', 'Ouverture Polonaise'],
    ]);

    // ------------ UTILS GÉNÉRAUX ------------
    const FR = new Intl.DisplayNames(['fr'], { type: 'region' });

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, s =>
        ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[s])
      );
    }

    function parsePgnTags(pgn) {
      const tags = {};
      const re = /\[(\w+)\s+"([^"]*)"\]/g;
      let m;
      while ((m = re.exec(pgn)) !== null) tags[m[1]] = m[2];
      return tags;
    }

    function getCountryNameFromUrl(url) {
      try {
        if (!url) return 'N/A';
        const code = url.split('/').pop();
        return code ? (FR.of(code) || code) : 'N/A';
      } catch {
        return 'N/A';
      }
    }

    function tokensToLineInfo(tokens, { limit = null } = {}) {
      if (!Array.isArray(tokens) || !tokens.length) {
        return { line: '', fen: '', moveCount: 0, moves: [] };
      }

      const trimmed = limit ? tokens.slice(0, limit) : [...tokens];
      const chess = new Chess();
      const parts = [];
      let moveNumber = 1;
      let turn = 'white';
      const applied = [];

      for (const move of trimmed) {
        if (!move) continue;
        try {
          chess.move(move);
          applied.push(move);
        } catch {
          break;
        }
        if (turn === 'white') {
          parts.push(`${moveNumber}. ${move}`);
          turn = 'black';
        } else {
          const lastIndex = parts.length - 1;
          if (lastIndex >= 0) parts[lastIndex] += ` ${move}`;
          moveNumber++;
          turn = 'white';
        }
      }

      const history = chess.history();
      const fen = history.length ? chess.fen() : '';
      const fallback = applied.length
        ? applied.join(' ')
        : trimmed.filter(Boolean).join(' ');

      return {
        line: parts.join(' ') || fallback,
        fen,
        moveCount: history.length,
        moves: applied,
      };
    }

    function buildLinePreview(tokens, { limit = null, extraClass = '', orientation = 'white' } = {}) {
      const info = tokensToLineInfo(tokens, { limit });
      if (!info.line) return { html: '', info };
      const fenAttr = info.fen ? ` data-fen="${escapeHtml(info.fen)}"` : '';
      const movesAttr = info.moves?.length
        ? ` data-moves="${escapeHtml(info.moves.join('|'))}"`
        : '';
      const classAttr = extraClass ? ` ${extraClass}` : '';
      const orientationAttr = orientation ? ` data-orientation="${orientation}"` : '';
      const html = `
        <button type="button" class="line-preview${classAttr}"${fenAttr}${movesAttr}${orientationAttr} data-line="${escapeHtml(info.line)}">
          ${escapeHtml(info.line)}
        </button>
      `;
      return { html, info };
    }

    function renderMainLine(tokens, orientation = 'white') {
      if (!tokens || !tokens.length) return '';
      const { html } = buildLinePreview(tokens, { limit: 14, orientation });
      if (!html) return '';
      return `
        <div class="line-block">
          <div class="line-label">Ligne principale</div>
          ${html}
        </div>
      `;
    }

    function renderObservedTraps(traps = [], orientation = 'white') {
      if (!Array.isArray(traps) || !traps.length) return '';
      const seen = new Set();
      const items = [];
      for (const trap of traps) {
        if (!trap?.id || seen.has(trap.id)) continue;
        seen.add(trap.id);
        const seq = Array.isArray(trap.seq) ? trap.seq : [];
        const { html } = buildLinePreview(seq, { orientation });
        if (!html) continue;
        const advice = trap.advice ? `<div class="line-meta">${escapeHtml(trap.advice)}</div>` : '';
        items.push(`
          <div class="observed-trap">
            <div class="trap-detected-name">💥 ${escapeHtml(trap.name)}</div>
            ${html}
            ${advice}
          </div>
        `);
      }
      if (!items.length) return '';
      return `
        <div class="observed-traps">
          <div class="observed-traps-header">Pièges repérés dans vos parties</div>
          ${items.join('')}
        </div>
      `;
    }

    function renderTrapRecommendations(recs = [], orientation = 'white') {
      if (!Array.isArray(recs) || !recs.length) return '';
      const chunks = recs.map(rec => {
        const seq = Array.isArray(rec.seq) ? rec.seq : [];
        const { html } = buildLinePreview(seq, { extraClass: 'trap-reco-line', orientation });
        if (!html) return '';
        return `
          <div class="trap-reco">
            <div class="trap-reco-name">💣 ${escapeHtml(rec.name)}</div>
            ${html}
            <div class="trap-reco-tip">💡 ${escapeHtml(rec.advice)}</div>
          </div>
        `;
      }).filter(Boolean);
      if (!chunks.length) return '';
      return `<div class="trap-recos">${chunks.join('')}</div>`;
    }

    function withTimeout(ms, signal) {
      const ctrl = new AbortController();
      const onAbort = () => ctrl.abort();
      if (signal) signal.addEventListener('abort', onAbort, { once: true });
      const t = setTimeout(() => ctrl.abort(), ms);
      const cleanup = () => clearTimeout(t);
      return { signal: ctrl.signal, cleanup };
    }

    // ------------ PGN → TOKENS ------------
    function loadPgnCompat(chessInstance, pgn, options) {
      const loader = typeof chessInstance.loadPgn === 'function'
        ? chessInstance.loadPgn
        : typeof chessInstance.load_pgn === 'function'
          ? chessInstance.load_pgn
          : null;
      if (!loader) throw new Error('No loadPgn function available on chess.js instance');
      return loader.call(chessInstance, pgn, options);
    }

    function normalizeToTokens(pgn) {
      if (!pgn || typeof pgn !== 'string') return [];

      try {
        const chess = new Chess();
        const loaded = loadPgnCompat(chess, pgn, { sloppy: true });
        if (loaded) {
          return chess.history({ verbose: true }).map(move =>
            (move?.san || '')
              .replace(/[+#]/g, '')
          );
        }
      } catch (err) {
        console.warn('Failed to parse PGN via chess.js', err);
      }

      let s = pgn
        .replace(/\{[^}]*\}/g, ' ')
        .replace(/;.*/g, ' ')
        .replace(/\([^)]*\)/g, ' ')
        .replace(/\$\d+/g, ' ');

      s = s.replace(/\b(1-0|0-1|1\/2-1\/2|\*)\b/g, ' ');
      s = s.replace(/\d+\.(\.\.)?/g, ' ');
      s = s.replace(/[+#]/g, '');
      s = s.replace(/\s+/g, ' ').trim();

      if (!s) return [];

      const tokens = s
        .split(' ')
        .filter(tok =>
          /^[O0]-O(-O)?$/.test(tok) ||
          /^[KQRNB]?[a-h]?[1-8]?x?[a-h][1-8](=[QRNB])?$/.test(tok) ||
          /^[a-h]x?[a-h][1-8](=[QRNB])?$/.test(tok) ||
          /^[a-h][1-8]$/.test(tok) ||
          /^[KQRNB][a-h][1-8]$/.test(tok)
        )
        .map(tok => tok.replace(/^0-0$/, 'O-O').replace(/^0-0-0$/, 'O-O-O'));

      return tokens;
    }

    function sanitizeSanSequence(seq = []) {
      return (seq || []).map((san) => String(san || '').replace(/[+#]/g, ''));
    }

    // ------------ MATCHING OUVERTURE ------------
    function getOpeningName(tokens) {
      if (!tokens.length) return 'Ouverture inconnue';
      const MAX_PLIES = Math.min(tokens.length, 20);
      for (let plies = MAX_PLIES; plies >= 2; plies--) {
        const prefix = tokens.slice(0, plies).join(' ');
        if (ECO_OPENINGS.has(prefix)) return ECO_OPENINGS.get(prefix);
        for (const [pattern, name] of ECO_OPENINGS.entries()) {
          if (prefix === pattern || prefix.startsWith(pattern + ' ')) return name;
        }
      }
      const first = tokens[0];
      if (FIRST_MOVE_FALLBACK.has(first)) return FIRST_MOVE_FALLBACK.get(first);
      if (first === 'O-O' || first === 'O-O-O') return 'Ouverture avec roque rapide';
      return 'Ouverture inconnue';
    }

    // ------------ FETCH & ANALYSE ------------
    const MONTHS_TO_CHECK = 3;
    const FETCH_TIMEOUT_MS = 10000;

    // Helper: côté au trait après N demi-coups
    function sideToMoveAfter(tokens) {
      // trait blanc au début; si nb de demi-coups est pair -> trait aux blancs, sinon noirs
      return (tokens.length % 2 === 0) ? 'white' : 'black';
    }

    async function fetchPlayerContext(username) {
      const base = `https://api.chess.com/pub/player/${encodeURIComponent(username)}`;
      const { signal, cleanup } = withTimeout(FETCH_TIMEOUT_MS);
      const [playerRes, statsRes] = await Promise.all([
        fetch(base, { signal }),
        fetch(`${base}/stats`, { signal }),
      ]);
      cleanup();

      if (!playerRes.ok) throw new Error('Joueur non trouvé');
      const playerData = await playerRes.json();
      const statsData = statsRes.ok ? await statsRes.json() : {};

      const now = new Date();
      const months = Array.from({ length: MONTHS_TO_CHECK }, (_, i) => {
        const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
        return { y: d.getFullYear(), m: String(d.getMonth() + 1).padStart(2, '0') };
      });

      const monthFetches = months.map(({ y, m }) => {
        const { signal, cleanup } = withTimeout(FETCH_TIMEOUT_MS);
        return fetch(`https://api.chess.com/pub/player/${encodeURIComponent(username)}/games/${y}/${m}`, { signal })
          .then((r) => {
            cleanup();
            return r.ok ? r.json() : { games: [] };
          })
          .catch(() => ({ games: [] }));
      });

      const monthPayloads = await Promise.allSettled(monthFetches);
      const recentGames = monthPayloads.flatMap((res) =>
        res.status === 'fulfilled' ? (res.value.games || []) : []
      );

      const games = recentGames.filter((g) => (g.rules ? g.rules === 'chess' : true));
      if (!games.length) throw new Error('Aucune partie récente trouvée');

      return { playerData, statsData, games };
    }

    function ensureOpeningBucket(collection, name) {
      if (!collection[name]) {
        collection[name] = {
          count: 0,
          wins: 0,
          draws: 0,
          losses: 0,
          traps: [],
          games: [],
          _sampleTokens: null,
          _samplePgn: null,
        };
      }
      return collection[name];
    }

    function aggregateOpenings(games, username) {
      const lower = String(username || '').toLowerCase();
      const whiteOpenings = {};
      const blackOpenings = {};

      for (const game of games) {
        if (!game?.pgn) continue;
        const youAreWhite =
          game.white &&
          game.white.username &&
          String(game.white.username).toLowerCase() === lower;
        const tokens = normalizeToTokens(game.pgn).slice(0, 20);
        const openingName = getOpeningName(tokens);
        const targetOpenings = youAreWhite ? whiteOpenings : blackOpenings;
        const bucket = ensureOpeningBucket(targetOpenings, openingName);

        if (!bucket._sampleTokens && tokens.length) bucket._sampleTokens = tokens;
        if (!bucket._samplePgn && game.pgn) bucket._samplePgn = game.pgn;

        bucket.count += 1;
        const whiteResult = game.white?.result;
        const blackResult = game.black?.result;
        let result = 'draw';
        if (whiteResult === 'win') result = youAreWhite ? 'win' : 'loss';
        else if (blackResult === 'win') result = youAreWhite ? 'loss' : 'win';
        else if (whiteResult === 'timeout' && blackResult === 'win') result = youAreWhite ? 'loss' : 'win';
        else if (blackResult === 'timeout' && whiteResult === 'win') result = youAreWhite ? 'win' : 'loss';

        if (result === 'win') bucket.wins += 1;
        else if (result === 'draw') bucket.draws += 1;
        else bucket.losses += 1;

        bucket.games.push({
          pgn: game.pgn,
          youAreWhite,
          endTime: game.end_time,
          url: game.url,
          opponent: youAreWhite ? game.black?.username : game.white?.username,
        });

        const trapScan = trapEngine.matchPgn(game.pgn, {
          openingLabel: openingName,
          side: youAreWhite ? 'white' : 'black',
          maxPlies: 24,
        });
        if (trapScan.hits.length) {
          bucket.traps.push(...trapScan.hits.slice(0, 2));
          bucket.isTrap = true;
        }
      }

      return { whiteOpenings, blackOpenings };
    }

    // Choix cadence par défaut en fonction des stats Chess.com
    function pickSpeedFromChesscom(statsData) {
      const order = ['chess_blitz', 'chess_rapid', 'chess_bullet'];
      for (const k of order) {
        if (statsData?.[k]?.last?.rating) {
          const map = { chess_blitz: 'blitz', chess_rapid: 'rapid', chess_bullet: 'bullet' };
          return map[k];
        }
      }
      return 'blitz';
    }

    function determineTargetSpeed(statsData, override) {
      if (override && override !== 'auto') return override;
      return pickSpeedFromChesscom(statsData);
    }

    function computePlayerRating(statsData) {
      return (
        statsData?.chess_blitz?.last?.rating ||
        statsData?.chess_rapid?.last?.rating ||
        statsData?.chess_bullet?.last?.rating ||
        statsData?.chess_rapid?.last?.best?.rating ||
        statsData?.chess_blitz?.last?.best?.rating ||
        statsData?.chess_bullet?.last?.best?.rating ||
        1500
      );
    }

    function readNumberInput(id, fallback = 0) {
      const el = document.getElementById(id);
      if (!el) return fallback;
      const value = Number(el.value);
      return Number.isFinite(value) ? value : fallback;
    }

    function readAnalysisConfig() {
      const gmMode = document.getElementById('gmMode').value;
      return {
        speedOverride: document.getElementById('speedSelect').value,
        ratingOffset: readNumberInput('ratingOffset', 0),
        gmMode,
        gmTopK: readNumberInput('gmTopK', 3),
        gmCoverage: readNumberInput('gmCoverage', 70) / 100,
        minMasterGames: readNumberInput('minMasterGames', 50),
        engine: {
          enabled: document.getElementById('engineEnabled').checked,
          path: document.getElementById('enginePath').value.trim(),
          depth: readNumberInput('engineDepth', 18),
          multipv: readNumberInput('engineMultiPv', 3),
        },
      };
    }

    function updateGmOptionVisibility() {
      const gmMode = document.getElementById('gmMode').value;
      const topKField = document.getElementById('gmTopKField');
      const coverageField = document.getElementById('gmCoverageField');
      if (gmMode === 'topK') {
        topKField.style.display = '';
        coverageField.style.display = 'none';
      } else if (gmMode === 'coverage') {
        topKField.style.display = 'none';
        coverageField.style.display = '';
      } else {
        topKField.style.display = 'none';
        coverageField.style.display = 'none';
      }
    }

    function updateEngineControlsAvailability() {
      const container = document.getElementById('engineSettings');
      const enabled = document.getElementById('engineEnabled').checked;
      if (!container) return;
      container.classList.toggle('is-disabled', !enabled);
      const inputs = container.querySelectorAll('input, select, textarea');
      inputs.forEach((input) => {
        if (input.id === 'engineEnabled') return;
        input.disabled = !enabled;
      });
      const pathInput = document.getElementById('enginePath');
      if (pathInput) {
        pathInput.placeholder = enabled
          ? 'Chemin Worker Stockfish (optionnel)'
          : 'Activez le moteur pour saisir un chemin';
      }
    }

    function setAnalysisMode(mode) {
      if (!Object.values(ANALYSIS_MODES).includes(mode)) return;
      state.mode = mode;
      const buttons = document.querySelectorAll('.mode-btn');
      buttons.forEach((btn) => {
        const isActive = btn.dataset.mode === mode;
        btn.classList.toggle('is-active', isActive);
        btn.setAttribute('aria-pressed', String(isActive));
      });
      const subtitle = document.querySelector('.subtitle');
      if (subtitle) {
        subtitle.textContent =
          mode === ANALYSIS_MODES.opponent
            ? 'Préparez vos parties contre un adversaire précis'
            : 'Analysez vos propres débuts et trouvez des gains rapides';
      }
      state.latestPrep = null;
      state.latestPlayer = null;
      hideResults();
    }

    async function enrichWithLichessSuggestions(openingsObject, playerElo, chesscomStats, config) {
      const entries = Object.entries(openingsObject);
      const speed = determineTargetSpeed(chesscomStats, config.speedOverride);
      const ratingBucket = pickLichessBucket(playerElo, { offset: config.ratingOffset || 0 });

      const topEntries = entries.sort((a, b) => b[1].count - a[1].count).slice(0, 8);

      const tasks = topEntries.map(async ([name, stats]) => {
        const sampleTokens = stats._sampleTokens || null;
        if (!sampleTokens?.length) return;
        try {
          const trait = sideToMoveAfter(sampleTokens);
          const out = await adviseFromLichess({
            tokens: sampleTokens,
            sideToMove: trait,
            playerRating: playerElo,
            ratingOffset: config.ratingOffset || 0,
            speed,
            top: 5,
          });
          if (out) {
            out.ratingBucket = ratingBucket;
            out.speed = speed;
            stats._lichess = out;
          }
        } catch (err) {
          console.warn('Explorer Lichess en échec pour', name, err?.status || '', err?.url || '', err);
        }
      });

      await Promise.allSettled(tasks);
      return { speed, ratingBucket };
    }

    function formatScoreLabel(score) {
      if (!score) return null;
      if (score.type === 'mate') {
        const sign = score.value > 0 ? '+' : '';
        return `#${sign}${score.value}`;
      }
      if (score.type === 'cp') {
        const value = Number(score.value || 0) / 100;
        return `${value.toFixed(2)}`;
      }
      return null;
    }

    async function annotateWithGmTheory(openingsObject, {
      playerColor,
      config,
      ratingBucket,
      speed,
    }) {
      const gmConfig = {
        gmMode: config.gmMode,
        gmTopK: config.gmTopK,
        coverageThreshold: config.gmCoverage,
        minMasterGames: config.minMasterGames,
      };
      const entries = Object.entries(openingsObject)
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 6);
      const ourSide = playerColor === 'white' ? 'black' : 'white';

      for (const [name, stats] of entries) {
        if (!stats._samplePgn) continue;
        const tokens = Array.isArray(stats._sampleTokens)
          ? stats._sampleTokens
          : normalizeToTokens(stats._samplePgn).slice(0, 24);
        try {
          const gmHits = await detectGmDeviationsFromPgn({
            pgn: stats._samplePgn,
            playerColor,
            limitPlies: 32,
            gmConfig,
          });
          const outOfBook = [];
          for (const item of gmHits) {
            const evaluation = item?.evaluation;
            if (!evaluation?.considered || evaluation.inBook !== false) continue;
            const tokensBefore = tokens.slice(0, item.ply.ply);
            let recommendation = null;
            let alternatives = [];
            let recommendationSource = 'lichess';

            try {
              const data = await fetchExplorer({
                fen: item.ply.fenAfter,
                speeds: [speed],
                ratings: [ratingBucket],
              });
              const moves = scoreMoves(data, ourSide).slice(0, 3);
              if (moves.length) {
                recommendation = moves[0];
                alternatives = moves;
              }
            } catch (err) {
              console.warn('Explorer suggestions indisponibles pour réponse GM', err?.status || '', err?.url || '', err);
            }

            if ((!recommendation || recommendation.total < 10) && config.engine?.enabled) {
              const engineResult = await engineManager.evaluateFen(item.ply.fenAfter, {
                depth: config.engine.depth,
                multipv: config.engine.multipv,
              });
              if (engineResult?.lines?.length) {
                const primary = engineResult.lines[0];
                if (primary?.pvSan?.length) {
                  const sanitizedPv = sanitizeSanSequence(primary.pvSan);
                  recommendation = {
                    san: sanitizedPv[0] || primary.pvSan[0],
                    uci: primary.pvUci?.[0] || engineResult.bestmove,
                    engineScore: primary.score,
                    pvSan: sanitizedPv,
                    pvUci: primary.pvUci,
                  };
                  alternatives = engineResult.lines.map((line) => {
                    const sanLine = sanitizeSanSequence(line.pvSan);
                    return {
                      san: sanLine[0] || line.pvSan[0],
                      uci: line.pvUci?.[0],
                      engineScore: line.score,
                      pvSan: sanLine,
                      pvUci: line.pvUci,
                    };
                  });
                  recommendationSource = 'engine';
                }
              }
            }

            if (!recommendation) continue;

            outOfBook.push({
              ply: item.ply,
              evaluation,
              masters: item.masters,
              recommendation,
              recommendationSource,
              alternatives,
              tokensBefore,
            });
          }
          if (outOfBook.length) {
            stats._gmOutOfBook = outOfBook;
          }
        } catch (err) {
          console.warn('Analyse théorie GM impossible pour', name, err);
        }
      }
    }

    async function computeImprovementPlans(openingsObject, {
      playerColor,
      ratingBucket,
      speed,
      threshold = 0.08,
      engineConfig = {},
    }) {
      const entries = Object.entries(openingsObject)
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, 5);
      for (const [name, stats] of entries) {
        if (!stats._samplePgn) continue;
        const tokens = Array.isArray(stats._sampleTokens)
          ? stats._sampleTokens
          : normalizeToTokens(stats._samplePgn).slice(0, 28);
        const plies = extractPliesFromPgn(stats._samplePgn, 32).filter(
          (ply) => ply.color === playerColor
        );
        const improvements = [];
        for (const ply of plies) {
          try {
            const data = await fetchExplorer({
              fen: ply.fenBefore,
              speeds: [speed],
              ratings: [ratingBucket],
            });
            const moves = scoreMoves(data, playerColor).slice(0, 5);
            if (!moves.length) continue;
            const ourMove = moves.find((m) => m.uci === ply.uci);
            const best = moves[0];
            if (!best) continue;
            const ourScore = ourMove ? ourMove.sideExpectedScore : 0;
            const delta = best.sideExpectedScore - ourScore;
            let recommendation = best;
            let alternatives = moves;
            let recommendationSource = 'lichess';

            if ((moves[0]?.total || 0) < 10 && engineConfig.enabled) {
              const engineResult = await engineManager.evaluateFen(ply.fenBefore, {
                depth: engineConfig.depth,
                multipv: engineConfig.multipv,
              });
              if (engineResult?.lines?.length) {
                const primary = engineResult.lines[0];
                if (primary?.pvSan?.length) {
                  const sanitizedPv = sanitizeSanSequence(primary.pvSan);
                  recommendation = {
                    san: sanitizedPv[0] || primary.pvSan[0],
                    uci: primary.pvUci?.[0] || engineResult.bestmove,
                    engineScore: primary.score,
                    pvSan: sanitizedPv,
                    pvUci: primary.pvUci,
                  };
                  alternatives = engineResult.lines.map((line) => {
                    const sanLine = sanitizeSanSequence(line.pvSan);
                    return {
                      san: sanLine[0] || line.pvSan[0],
                      uci: line.pvUci?.[0],
                      engineScore: line.score,
                      pvSan: sanLine,
                      pvUci: line.pvUci,
                    };
                  });
                  recommendationSource = 'engine';
                }
              }
            }

            if (delta < threshold && recommendationSource !== 'engine') continue;

            const tokensBefore = tokens.slice(0, Math.max(0, ply.ply - 1));
            improvements.push({
              ply,
              delta,
              recommendation,
              recommendationSource,
              alternatives,
              tokensBefore,
              ourMove,
            });
            if (improvements.length >= 3) break;
          } catch (err) {
            console.warn('Impossible de calculer une amélioration pour', name, err);
          }
        }
        if (improvements.length) {
          stats._improvements = improvements;
        }
      }
    }

    async function runAnalysis() {
      const usernameInput = document.getElementById('username');
      const btn = document.getElementById('analyzeBtn');
      const username = usernameInput.value.trim();
      if (!username) {
        showError('Veuillez entrer un pseudo Chess.com');
        return;
      }

      const config = readAnalysisConfig();
      state.config = config;

      hideError();
      showLoading();
      hideResults();
      btn.disabled = true;

      if (config.engine?.enabled && !config.engine.path) {
        showError('Chemin du moteur Stockfish requis pour l\'analyse locale');
        hideLoading();
        btn.disabled = false;
        return;
      }

      if (config.engine?.enabled) {
        await engineManager.configure({
          enabled: true,
          path: config.engine.path,
          depth: config.engine.depth,
          multipv: config.engine.multipv,
        });
      } else {
        engineManager.dispose();
      }

      try {
        const context = await fetchPlayerContext(username);
        const { playerData, statsData, games } = context;
        const { whiteOpenings, blackOpenings } = aggregateOpenings(games, username);
        const playerElo = computePlayerRating(statsData);

        const whiteMeta = await enrichWithLichessSuggestions(
          whiteOpenings,
          playerElo,
          statsData,
          config
        );
        const blackMeta = await enrichWithLichessSuggestions(
          blackOpenings,
          playerElo,
          statsData,
          config
        );

        state.speed = whiteMeta?.speed || blackMeta?.speed || determineTargetSpeed(statsData, config.speedOverride);
        state.ratingBucket = whiteMeta?.ratingBucket || blackMeta?.ratingBucket || pickLichessBucket(playerElo, { offset: config.ratingOffset || 0 });

        if (state.mode === ANALYSIS_MODES.opponent) {
          await annotateWithGmTheory(whiteOpenings, {
            playerColor: 'white',
            config,
            ratingBucket: state.ratingBucket,
            speed: state.speed,
          });
          await annotateWithGmTheory(blackOpenings, {
            playerColor: 'black',
            config,
            ratingBucket: state.ratingBucket,
            speed: state.speed,
          });
        } else {
          await annotateWithGmTheory(whiteOpenings, {
            playerColor: 'white',
            config,
            ratingBucket: state.ratingBucket,
            speed: state.speed,
          });
          await annotateWithGmTheory(blackOpenings, {
            playerColor: 'black',
            config,
            ratingBucket: state.ratingBucket,
            speed: state.speed,
          });
          await computeImprovementPlans(whiteOpenings, {
            playerColor: 'white',
            ratingBucket: state.ratingBucket,
            speed: state.speed,
            threshold: 0.08,
            engineConfig: config.engine,
          });
          await computeImprovementPlans(blackOpenings, {
            playerColor: 'black',
            ratingBucket: state.ratingBucket,
            speed: state.speed,
            threshold: 0.08,
            engineConfig: config.engine,
          });
        }

        state.latestPrep = {
          mode: state.mode,
          player: playerData,
          stats: statsData,
          whiteOpenings,
          blackOpenings,
          speed: state.speed,
          ratingBucket: state.ratingBucket,
          config,
        };
        state.latestPlayer = playerData;

        displayPlayerInfo(playerData, statsData);
        displayOpenings(whiteOpenings, blackOpenings, state.mode);
        showPrepActions();
      } catch (err) {
        showError(err.message || 'Erreur inconnue');
      } finally {
        hideLoading();
        btn.disabled = false;
      }
    }

    // ------------ UI ------------
    function renderLichessAdvice(stats, { orientation = 'white', side = 'white', mode = state.mode } = {}) {
      if (!stats._lichess?.suggestions?.length) return '';
      const o = stats._lichess;
      const tag = o.openingName ? ` (${o.openingName}${o.eco ? ' – ' + o.eco : ''})` : '';
      const baseTokens = Array.isArray(stats._sampleTokens) ? stats._sampleTokens : [];
      const ourSide = mode === ANALYSIS_MODES.opponent ? (side === 'white' ? 'black' : 'white') : side;
      const items = o.suggestions.slice(0, 3).map(s => {
        const tokens = sanitizeSanSequence([...baseTokens, s.san].filter(Boolean));
        const { html, info } = buildLinePreview(tokens, { limit: baseTokens.length + 1, orientation });
        const fallbackText = info.line || s.san;
        const trapScan = trapEngine.matchTokens(tokens, {
          openingLabel: '',
          side: ourSide,
          maxPlies: tokens.length + 4,
        });
        const trapBadge = trapScan.hits.length ? '<span class="badge badge-trap">Piège dispo</span>' : '';
        const button = html || `
          <button
            type="button"
            class="line-preview"
            data-line="${escapeHtml(fallbackText)}"
            data-orientation="${orientation}"
            ${info.moves?.length ? `data-moves="${escapeHtml(info.moves.join('|'))}"` : ''}
            ${info.fen ? `data-fen="${escapeHtml(info.fen)}"` : ''}
          >
            ${escapeHtml(fallbackText)}
          </button>
        `;
        const score = Math.round((s.sideExpectedScore || 0) * 100);
        return `
          <li>
            ${button}
            <div class="line-meta">Score attendu ${score}% · ${s.total} parties ${trapBadge}</div>
          </li>
        `;
      }).join('');
      return `
        <details class="lichess-advice">
          <summary>Coups recommandés (Lichess)${tag}</summary>
          <ul>${items}</ul>
        </details>
      `;
    }

    function buildPreviewButton(tokens, { orientation }) {
      const { html, info } = buildLinePreview(tokens, { limit: tokens.length + 1, orientation });
      if (html) return html;
      const fallbackText = info.line || tokens.join(' ');
      return `
        <button
          type="button"
          class="line-preview"
          data-line="${escapeHtml(fallbackText)}"
          data-orientation="${orientation}"
          ${info.moves?.length ? `data-moves="${escapeHtml(info.moves.join('|'))}"` : ''}
          ${info.fen ? `data-fen="${escapeHtml(info.fen)}"` : ''}
        >
          ${escapeHtml(fallbackText)}
        </button>
      `;
    }

    function renderGmOutOfBook(stats, { orientation, side, mode }) {
      const entries = Array.isArray(stats._gmOutOfBook) ? stats._gmOutOfBook : [];
      if (!entries.length) return '';
      const ourSide = mode === ANALYSIS_MODES.opponent ? (side === 'white' ? 'black' : 'white') : side;
      const items = entries.slice(0, 3).map((entry) => {
        const moveLabel = `${entry.ply.moveNumber}${entry.ply.color === 'white' ? '.' : '...'} ${escapeHtml(entry.ply.san)}`;
        const coverage = entry.evaluation?.coverage != null
          ? `Couverture GM ${Math.round((entry.evaluation.coverage || 0) * 100)}%`
          : '';
        const totalMasters = entry.evaluation?.total ? `${entry.evaluation.total} parties` : '';
        const recommendation = entry.recommendation || {};
        const recommendationSan = recommendation.san || (Array.isArray(recommendation.pvSan) ? recommendation.pvSan[0] : '');
        const sourceTag = entry.recommendationSource === 'engine'
          ? '<span class="source-tag">Moteur local</span>'
          : '<span class="source-tag">Explorer Lichess</span>';
        const scoreLabel = recommendation.engineScore ? formatScoreLabel(recommendation.engineScore) : null;
        const tokens = sanitizeSanSequence([
          ...(entry.tokensBefore || []),
          ...(Array.isArray(recommendation.pvSan) && recommendation.pvSan.length
            ? recommendation.pvSan
            : recommendationSan
              ? [recommendationSan]
              : []),
        ]);
        const preview = tokens.length
          ? buildPreviewButton(tokens, { orientation: ourSide === 'black' ? 'black' : 'white' })
          : '';
        const totalVolume = entry.evaluation?.total || 0;
        const gmMoves = totalVolume && Array.isArray(entry.evaluation?.pickedMoves)
          ? entry.evaluation.pickedMoves
              .map((m) => `${escapeHtml(m.san || '')} (${Math.round((m.volume / totalVolume) * 100)}%)`)
              .join(', ')
          : '';

        return `
          <div class="gm-entry">
            <div class="gm-entry-title">${moveLabel} — ${sourceTag}</div>
            <div class="gm-meta">
              ${coverage ? `<span>${coverage}</span>` : ''}
              ${totalMasters ? `<span>· ${totalMasters}</span>` : ''}
              ${gmMoves ? `<span>· Refs GM: ${gmMoves}</span>` : ''}
              ${scoreLabel ? `<span>· Eval ${escapeHtml(scoreLabel)}</span>` : ''}
            </div>
            <div class="gm-reco">
              ${preview}
            </div>
          </div>
        `;
      }).join('');
      return `
        <div class="gm-section">
          <div class="gm-entry-title">Sorties de théorie GM</div>
          ${items}
        </div>
      `;
    }

    function renderImprovements(stats, { orientation, side }) {
      const entries = Array.isArray(stats._improvements) ? stats._improvements : [];
      if (!entries.length) return '';
      const items = entries.map((entry) => {
        const moveLabel = `${entry.ply.moveNumber}${entry.ply.color === 'white' ? '.' : '...'} ${escapeHtml(entry.ply.san)}`;
        const recommendedSan = entry.recommendation?.san || (Array.isArray(entry.recommendation?.pvSan) ? entry.recommendation.pvSan[0] : '');
        const sourceTag = entry.recommendationSource === 'engine'
          ? '<span class="source-tag">Moteur local</span>'
          : '<span class="source-tag">Explorer Lichess</span>';
        const scoreLabel = entry.recommendation?.engineScore ? formatScoreLabel(entry.recommendation.engineScore) : null;
        const tokens = sanitizeSanSequence([
          ...(entry.tokensBefore || []),
          ...(Array.isArray(entry.recommendation?.pvSan) && entry.recommendation.pvSan.length
            ? entry.recommendation.pvSan
            : recommendedSan ? [recommendedSan] : []),
        ]);
        const preview = tokens.length
          ? buildPreviewButton(tokens, { orientation })
          : '';
        const deltaLabel = `<span class="delta-positive">+${(entry.delta * 100).toFixed(1)}%</span>`;

        return `
          <div class="improvement-entry">
            <div class="improvement-entry-title">${moveLabel} — vous avez joué <strong>${escapeHtml(entry.ourMove?.san || entry.ply.san)}</strong></div>
            <div class="improvement-meta">
              ${sourceTag}
              <span>· Gain attendu ${deltaLabel}</span>
              ${scoreLabel ? `<span>· Eval ${escapeHtml(scoreLabel)}</span>` : ''}
            </div>
            <div class="improvement-reco">
              ${preview}
            </div>
          </div>
        `;
      }).join('');
      return `
        <div class="improvement-section">
          <div class="gm-entry-title">Axes d'amélioration recommandés</div>
          ${items}
        </div>
      `;
    }

    function displayPlayerInfo(playerData, statsData) {
      const playerInfoDiv = document.getElementById('playerInfo');
      const rapid = statsData?.chess_rapid?.last?.rating ?? 'N/A';
      const blitz = statsData?.chess_blitz?.last?.rating ?? 'N/A';
      const bullet = statsData?.chess_bullet?.last?.rating ?? 'N/A';
      const country = getCountryNameFromUrl(playerData.country);

      playerInfoDiv.innerHTML = `
            <div class="player-info">
              <h2>${escapeHtml(playerData.username || '')}</h2>
              <div class="stats">
                <div class="stat-card"><div class="stat-label">Rapid</div><div class="stat-value">${rapid}</div></div>
                <div class="stat-card"><div class="stat-label">Blitz</div><div class="stat-value">${blitz}</div></div>
                <div class="stat-card"><div class="stat-label">Bullet</div><div class="stat-value">${bullet}</div></div>
                <div class="stat-card"><div class="stat-label">Pays</div><div class="stat-value">${escapeHtml(country)}</div></div>
              </div>
            </div>
          `;
      playerInfoDiv.style.display = 'block';
    }

    function formatOpeningRow(name, stats, extraHtml = '', side = 'white', mode = state.mode) {
      const winRate = stats.count ? ((stats.wins / stats.count) * 100).toFixed(1) : '0.0';
      const drawRate = stats.count ? ((stats.draws / stats.count) * 100).toFixed(1) : '0.0';
      const lossRate = stats.count ? ((stats.losses / stats.count) * 100).toFixed(1) : '0.0';
      const safeName = escapeHtml(name);
      const badges = [];
      if (stats._gmOutOfBook?.length) badges.push('<span class="badge badge-gm">Hors théorie</span>');
      if (mode === ANALYSIS_MODES.self && stats._improvements?.length) badges.push('<span class="badge badge-improve">Axes +score</span>');
      const badgesHtml = badges.length ? ` ${badges.join(' ')}` : '';
      const labelHtml = `${stats.isTrap ? `<span class="trap-name">${safeName}</span>` : safeName}${badgesHtml}`;
      const { line: mainLineText, moves: mainMoves } = tokensToLineInfo(stats._sampleTokens || [], { limit: 30 });
      const orientation = mode === ANALYSIS_MODES.opponent
        ? side === 'white' ? 'black' : 'white'
        : side === 'black' ? 'black' : 'white';
      const dataMainMoves = mainMoves?.length
        ? ` data-main-moves="${escapeHtml(mainMoves.join('|'))}"`
        : '';
      const dataMainLine = mainLineText
        ? ` data-main-line="${escapeHtml(mainLineText)}"`
        : '';
      const dataOrientation = ` data-orientation="${orientation}"`;
      const dataName = ` data-opening-name="${escapeHtml(name)}"`;

      return `
            <div class="opening-item"${dataMainMoves}${dataMainLine}${dataOrientation}${dataName}>
              <div class="opening-name">${labelHtml}</div>
              <div class="opening-stats">
                <span class="opening-stat">📊 ${stats.count} parties</span>
                <span class="opening-stat win-rate">✓ ${winRate}%</span>
                <span class="opening-stat draw-rate">= ${drawRate}%</span>
                <span class="opening-stat loss-rate">✗ ${lossRate}%</span>
              </div>
              <div class="progress-bar">
                <div class="progress-win" style="width:${winRate}%"></div>
                <div class="progress-draw" style="width:${drawRate}%"></div>
                <div class="progress-loss" style="width:${lossRate}%"></div>
              </div>
              ${extraHtml}
            </div>
          `;
    }

    function buildOpeningSections(name, stats, side, mode = state.mode) {
      const sections = [];
      const orientation = mode === ANALYSIS_MODES.opponent
        ? side === 'white' ? 'black' : 'white'
        : side === 'black' ? 'black' : 'white';
      const mainLine = renderMainLine(stats._sampleTokens || [], orientation);
      if (mainLine) sections.push(mainLine);

      const observed = renderObservedTraps(stats.traps || [], orientation);
      if (observed) sections.push(observed);

      const recs = trapEngine.recommendByOpening(name, side, 3);
      const recsHtml = renderTrapRecommendations(recs, orientation);
      if (recsHtml) sections.push(recsHtml);

      const lichessHtml = renderLichessAdvice(stats, { orientation, side, mode });
      if (lichessHtml) sections.push(lichessHtml);

      const gmHtml = renderGmOutOfBook(stats, { orientation, side, mode });
      if (gmHtml) sections.push(gmHtml);

      if (mode === ANALYSIS_MODES.self) {
        const improvementHtml = renderImprovements(stats, { orientation, side });
        if (improvementHtml) sections.push(improvementHtml);
      }

      return sections.join('');
    }

    function displayOpenings(whiteOpenings, blackOpenings, mode = state.mode) {
      const whiteDiv = document.getElementById('whiteOpenings');
      const blackDiv = document.getElementById('blackOpenings');

      const sortedWhite = Object.entries(whiteOpenings).sort((a, b) => b[1].count - a[1].count);
      const sortedBlack = Object.entries(blackOpenings).sort((a, b) => b[1].count - a[1].count);

      whiteDiv.innerHTML = sortedWhite.length
        ? sortedWhite.slice(0, 10).map(([name, stats]) => {
          const sections = buildOpeningSections(name, stats, 'white', mode);
          return formatOpeningRow(name, stats, sections, 'white', mode);
        }).join('')
        : '<div class="no-data">Aucune donnée disponible</div>';

      blackDiv.innerHTML = sortedBlack.length
        ? sortedBlack.slice(0, 10).map(([name, stats]) => {
          const sections = buildOpeningSections(name, stats, 'black', mode);
          return formatOpeningRow(name, stats, sections, 'black', mode);
        }).join('')
        : '<div class="no-data">Aucune donnée disponible</div>';

      document.getElementById('openingsSection').style.display = 'grid';
    }

    function showLoading() {
      document.getElementById('loading').style.display = 'block';
    }
    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }
    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = `❌ Erreur : ${message}`;
      errorDiv.style.display = 'block';
    }
    function hideError() {
      document.getElementById('error').style.display = 'none';
    }
    function hideResults() {
      document.getElementById('playerInfo').style.display = 'none';
      document.getElementById('openingsSection').style.display = 'none';
      document.getElementById('prepActions').style.display = 'none';
      pinnedAnchor = null;
      hideBoardPreview();
    }

    function showPrepActions() {
      document.getElementById('prepActions').style.display = 'flex';
    }

    function topOpenings(openings, limit = 3) {
      return Object.entries(openings || {})
        .sort((a, b) => b[1].count - a[1].count)
        .slice(0, limit);
    }

    function downloadBlob(filename, blob) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
    }

    function buildMarkdown(prep) {
      const lines = [];
      const playerName = prep.player?.username || 'Joueur';
      lines.push(`# Préparation ${playerName}`);
      lines.push('');
      lines.push(`- Mode : ${prep.mode === ANALYSIS_MODES.opponent ? 'Adversaire' : 'Analyse perso'}`);
      lines.push(`- Cadence cible : ${prep.speed}`);
      lines.push(`- Bucket Lichess : ${prep.ratingBucket}`);
      lines.push('');

      const sections = [
        { label: 'Plans contre ses Blancs', items: topOpenings(prep.whiteOpenings) },
        { label: 'Plans contre ses Noirs', items: topOpenings(prep.blackOpenings) },
      ];

      for (const section of sections) {
        if (!section.items.length) continue;
        lines.push(`## ${section.label}`);
        lines.push('');
        for (const [name, stats] of section.items) {
          lines.push(`### ${name} (${stats.count} parties)`);
          if (stats._lichess?.suggestions?.length) {
            lines.push('**Coups recommandés :**');
            for (const sug of stats._lichess.suggestions.slice(0, 3)) {
              const score = Math.round((sug.sideExpectedScore || 0) * 100);
              lines.push(`- ${sug.san} · score ${score}% (${sug.total} parties)`);
            }
          }
          if (Array.isArray(stats._gmOutOfBook) && stats._gmOutOfBook.length) {
            lines.push('**Sorties de théorie GM :**');
            for (const gm of stats._gmOutOfBook) {
              const san = gm.recommendation?.san || (gm.recommendation?.pvSan?.[0] || '');
              const coverage = gm.evaluation?.coverage != null ? `${Math.round((gm.evaluation.coverage || 0) * 100)}%` : 'n/a';
              lines.push(`- ${gm.ply.moveNumber}${gm.ply.color === 'white' ? '.' : '...'} ${gm.ply.san} → jouer ${san} (couverture GM ${coverage})`);
            }
          }
          if (Array.isArray(stats._improvements) && stats._improvements.length) {
            lines.push('**Axes d’amélioration :**');
            for (const imp of stats._improvements) {
              const san = imp.recommendation?.san || (imp.recommendation?.pvSan?.[0] || '');
              lines.push(`- ${imp.ply.moveNumber}${imp.ply.color === 'white' ? '.' : '...'} ${imp.ply.san} → préférer ${san} (gain +${(imp.delta * 100).toFixed(1)}%)`);
            }
          }
          lines.push('');
        }
      }
      return lines.join('\n');
    }

    function exportPrep(format) {
      const prep = state.latestPrep;
      if (!prep) {
        showError('Aucune analyse à exporter pour le moment');
        return;
      }
      const playerName = prep.player?.username || 'joueur';
      if (format === 'json') {
        const blob = new Blob([JSON.stringify(prep, null, 2)], { type: 'application/json' });
        downloadBlob(`prep-${playerName}.json`, blob);
        return;
      }
      if (format === 'markdown') {
        const markdown = buildMarkdown(prep);
        const blob = new Blob([markdown], { type: 'text/markdown' });
        downloadBlob(`prep-${playerName}.md`, blob);
        return;
      }
      if (format === 'pdf') {
        const markdown = buildMarkdown(prep);
        const win = window.open('', '_blank');
        if (!win) {
          showError('Impossible d\'ouvrir la fenêtre d\'export PDF');
          return;
        }
        win.document.write(`
          <html>
            <head>
              <title>Préparation ${playerName}</title>
              <style>
                body { font-family: 'Segoe UI', sans-serif; padding: 32px; color: #111827; }
                h1 { font-size: 28px; margin-bottom: 16px; }
                h2 { margin-top: 24px; font-size: 22px; }
                h3 { margin-top: 18px; font-size: 18px; }
                ul { margin-left: 20px; }
                pre { white-space: pre-wrap; }
              </style>
            </head>
            <body>
              <pre>${markdown.replace(/</g, '&lt;')}</pre>
            </body>
          </html>
        `);
        win.document.close();
        setTimeout(() => {
          win.print();
        }, 250);
      }
    }

    // ------------ BOARD PREVIEW ------------
    const boardPreview = document.getElementById('boardPreview');
    const boardPreviewBoardEl = document.getElementById('boardPreviewBoard');
    const boardPreviewCaption = document.getElementById('boardPreviewCaption');
    const boardPreviewChessboard = boardPreviewBoardEl
      ? new Chessboard(boardPreviewBoardEl, {
          assetsUrl: 'https://unpkg.com/cm-chessboard@7.11.0/assets/',
          style: {
            showCoordinates: false,
            borderType: BORDER_TYPE.none,
            animationDuration: 0,
          },
        })
      : null;
    if (boardPreviewChessboard) {
      boardPreviewChessboard.setPosition(FEN.empty).catch(() => {});
    }
    let pinnedAnchor = null;

    function setBoardOrientation(boardInstance, orientation) {
      if (!boardInstance || !boardInstance.setOrientation) return;
      const target = orientation === 'black' ? 'black' : 'white';
      try {
        const maybe = boardInstance.setOrientation(target);
        if (maybe?.catch) maybe.catch(() => {});
      } catch (err) {
        console.warn('Failed to set orientation', err);
      }
    }

    function updateBoardPreviewPosition(fen) {
      if (!boardPreviewChessboard) return;
      const targetFen = fen || FEN.empty;
      boardPreviewChessboard
        .setPosition(targetFen)
        .catch(err => {
          console.warn('Failed to set preview FEN', err);
          boardPreviewChessboard.setPosition(FEN.empty).catch(() => {});
        });
    }

    function positionBoardPreview(anchor) {
      const rect = anchor.getBoundingClientRect();
      const boardWidth = boardPreview.offsetWidth || 240;
      const boardHeight = boardPreview.offsetHeight || 260;
      let left = window.scrollX + rect.right + 12;
      let top = window.scrollY + rect.top;

      const viewportRight = window.scrollX + window.innerWidth;
      if (left + boardWidth > viewportRight - 16) {
        left = window.scrollX + rect.left - boardWidth - 12;
      }
      if (left < window.scrollX + 12) left = window.scrollX + 12;

      const viewportBottom = window.scrollY + window.innerHeight;
      if (top + boardHeight > viewportBottom - 16) {
        top = viewportBottom - boardHeight - 16;
      }
      if (top < window.scrollY + 12) top = window.scrollY + 12;

      boardPreview.style.left = `${left}px`;
      boardPreview.style.top = `${top}px`;
    }

    function showBoardPreview(anchor) {
      if (!anchor) return;
      const fen = anchor.dataset.fen || '';
      const line = anchor.dataset.line || '';
      const orientation = anchor.dataset.orientation === 'black' ? 'black' : 'white';
      setBoardOrientation(boardPreviewChessboard, orientation);
      updateBoardPreviewPosition(fen);
      boardPreviewCaption.textContent = line;
      boardPreview.style.display = 'block';
      positionBoardPreview(anchor);
    }

    function hideBoardPreview() {
      boardPreview.style.display = 'none';
    }

    // ------------ MODAL BOARD ------------
    const lineModal = document.getElementById('lineModal');
    const lineModalTitle = document.getElementById('lineModalTitle');
    const lineModalSummary = document.getElementById('lineModalSummary');
    const lineModalMoves = document.getElementById('lineModalMoves');
    const lineModalLichess = document.getElementById('lineModalLichess');
    const lineModalClose = document.getElementById('lineModalClose');
    const lineModalStart = document.getElementById('lineModalStart');
    const lineModalPrev = document.getElementById('lineModalPrev');
    const lineModalNext = document.getElementById('lineModalNext');
    const lineModalEnd = document.getElementById('lineModalEnd');
    const lineModalBoardEl = document.getElementById('lineModalBoard');
    const lineModalChessboard = lineModalBoardEl
      ? new Chessboard(lineModalBoardEl, {
          assetsUrl: 'https://unpkg.com/cm-chessboard@7.11.0/assets/',
          style: {
            showCoordinates: true,
            borderType: BORDER_TYPE.frame,
          },
        })
      : null;
    if (lineModalChessboard) {
      lineModalChessboard.setPosition(FEN.start).catch(() => {});
    }
    let lineModalMoveButtons = [];
    let lineModalState = {
      tokens: [],
      fens: [FEN.start],
      index: 0,
      orientation: 'white',
      summary: '',
      title: 'Séquence',
    };

    function parseMovesAttr(value = '') {
      if (!value) return [];
      return value
        .split('|')
        .map(v => v.trim())
        .filter(Boolean);
    }

    function prepareModalState(tokens = []) {
      const chess = new Chess();
      const sanitized = [];
      const fens = [chess.fen()];
      for (const move of tokens) {
        if (!move) continue;
        try {
          chess.move(move);
          sanitized.push(move);
          fens.push(chess.fen());
        } catch (err) {
          console.warn('Invalid move skipped in modal', move, err);
          break;
        }
      }
      return { sanitized, fens: fens.length ? fens : [FEN.start] };
    }

    function lichessUrlFromFen(fen, orientation = 'white') {
      if (!fen) fen = FEN.start;
      const encoded = fen.replace(/\s+/g, ' ').trim().replace(/ /g, '_');
      const color = orientation === 'black' ? 'black' : 'white';
      return `https://lichess.org/analysis/standard/${encoded}?color=${color}`;
    }

    function renderModalMoves(tokens = []) {
      if (!lineModalMoves) return;
      const chips = [`<button type="button" class="move-chip" data-ply="0">Début</button>`];
      tokens.forEach((move, idx) => {
        const ply = idx + 1;
        const moveNumber = Math.ceil(ply / 2);
        const isWhite = ply % 2 === 1;
        const label = isWhite
          ? `${moveNumber}. ${move}`
          : `${moveNumber}... ${move}`;
        chips.push(`
          <button type="button" class="move-chip" data-ply="${ply}">
            ${escapeHtml(label)}
          </button>
        `);
      });
      lineModalMoves.innerHTML = chips.join('');
      lineModalMoveButtons = Array.from(lineModalMoves.querySelectorAll('.move-chip'));
    }

    function updateModalControls() {
      if (!lineModalStart || !lineModalPrev || !lineModalNext || !lineModalEnd) return;
      lineModalStart.disabled = lineModalState.index === 0;
      lineModalPrev.disabled = lineModalState.index === 0;
      const atEnd = lineModalState.index >= lineModalState.tokens.length;
      lineModalNext.disabled = atEnd;
      lineModalEnd.disabled = atEnd;
    }

    function updateModalMovesHighlight() {
      if (!lineModalMoveButtons.length) return;
      lineModalMoveButtons.forEach(btn => {
        const ply = Number(btn.dataset.ply || '0');
        btn.classList.toggle('is-active', ply === lineModalState.index);
        btn.classList.toggle('is-past', ply < lineModalState.index);
      });
    }

    function updateLineModal(index) {
      if (!lineModal) return;
      const maxIndex = Math.max(0, lineModalState.fens.length - 1);
      const clamped = Math.max(0, Math.min(index, maxIndex));
      lineModalState.index = clamped;
      const fen = lineModalState.fens[clamped] || FEN.start;
      setBoardOrientation(lineModalChessboard, lineModalState.orientation);
      if (lineModalChessboard) {
        lineModalChessboard.setPosition(fen).catch(() => {});
      }
      const descriptors = [];
      if (lineModalState.summary) descriptors.push(lineModalState.summary);
      if (clamped === 0) {
        descriptors.push('Position initiale');
      } else {
        const demi = clamped;
        const moveWord = demi > 1 ? 'demi-coups' : 'demi-coup';
        descriptors.push(`Après ${demi} ${moveWord}`);
      }
      const side = clamped % 2 === 0 ? 'Trait aux Blancs' : 'Trait aux Noirs';
      descriptors.push(side);
      if (lineModalSummary) lineModalSummary.textContent = descriptors.join(' • ');
      if (lineModalTitle) lineModalTitle.textContent = lineModalState.title || 'Séquence';
      if (lineModalLichess) lineModalLichess.href = lichessUrlFromFen(fen, lineModalState.orientation);
      updateModalControls();
      updateModalMovesHighlight();
    }

    function openLineModal({ tokens, title, summary, orientation }) {
      if (!lineModal) return;
      const prep = prepareModalState(tokens);
      lineModalState = {
        tokens: prep.sanitized,
        fens: prep.fens,
        index: 0,
        orientation: orientation === 'black' ? 'black' : 'white',
        summary: summary || '',
        title: title || 'Séquence',
      };
      renderModalMoves(lineModalState.tokens);
      updateLineModal(0);
      lineModal.classList.add('is-open');
      lineModal.setAttribute('aria-hidden', 'false');
      document.body.classList.add('modal-open');
      queueMicrotask(() => {
        lineModalClose?.focus?.();
      });
    }

    function closeLineModal() {
      if (!lineModal) return;
      lineModal.classList.remove('is-open');
      lineModal.setAttribute('aria-hidden', 'true');
      document.body.classList.remove('modal-open');
    }

    function openLineModalFromElement(element) {
      if (!element) return false;
      const moves = element.dataset.moves || element.dataset.mainMoves;
      const tokens = parseMovesAttr(moves || '');
      if (!tokens.length) return false;
      const orientation = element.dataset.orientation === 'black' ? 'black' : 'white';
      const enclosingOpening = element.closest('.opening-item');
      const openingName = element.dataset.openingName
        || enclosingOpening?.dataset?.openingName
        || 'Séquence';
      const summary = element.dataset.line
        || element.dataset.mainLine
        || enclosingOpening?.dataset?.mainLine
        || '';
      openLineModal({ tokens, title: openingName, summary, orientation });
      return true;
    }

    document.body.addEventListener('mouseover', event => {
      const anchor = event.target.closest('.line-preview');
      if (!anchor) {
        if (!pinnedAnchor) hideBoardPreview();
        return;
      }
      if (pinnedAnchor) return;
      showBoardPreview(anchor);
    });

    document.body.addEventListener('click', event => {
      const previewBtn = event.target.closest('.line-preview');
      if (previewBtn) {
        event.preventDefault();
        openLineModalFromElement(previewBtn);
        pinnedAnchor = null;
        hideBoardPreview();
        return;
      }

      const openingCard = event.target.closest('.opening-item');
      if (
        openingCard &&
        !event.target.closest('.line-preview') &&
        !event.target.closest('a') &&
        !event.target.closest('summary') &&
        !event.target.closest('button')
      ) {
        if (openLineModalFromElement(openingCard)) {
          event.preventDefault();
          pinnedAnchor = null;
          hideBoardPreview();
          return;
        }
      }

      if (!event.target.closest('#boardPreview')) {
        pinnedAnchor = null;
        hideBoardPreview();
      }
    });

    document.body.addEventListener('focusin', event => {
      const anchor = event.target.closest('.line-preview');
      if (anchor) {
        pinnedAnchor = anchor;
        showBoardPreview(anchor);
      } else if (!event.target.closest('#boardPreview')) {
        pinnedAnchor = null;
        hideBoardPreview();
      }
    });

    window.addEventListener('scroll', () => {
      if (pinnedAnchor && boardPreview.style.display === 'block') {
        positionBoardPreview(pinnedAnchor);
      }
    });

    window.addEventListener('resize', () => {
      if (pinnedAnchor && boardPreview.style.display === 'block') {
        positionBoardPreview(pinnedAnchor);
      }
    });

    if (lineModalMoves) {
      lineModalMoves.addEventListener('click', event => {
        const chip = event.target.closest('.move-chip');
        if (!chip) return;
        const ply = Number(chip.dataset.ply || '0');
        updateLineModal(ply);
      });
    }

    lineModalStart?.addEventListener('click', () => updateLineModal(0));
    lineModalPrev?.addEventListener('click', () => updateLineModal(lineModalState.index - 1));
    lineModalNext?.addEventListener('click', () => updateLineModal(lineModalState.index + 1));
    lineModalEnd?.addEventListener('click', () => updateLineModal(lineModalState.tokens.length));
    lineModalClose?.addEventListener('click', () => closeLineModal());
    lineModal?.addEventListener('click', event => {
      if (event.target === lineModal) {
        closeLineModal();
      }
    });
    document.addEventListener('keydown', event => {
      if (event.key === 'Escape' && lineModal?.classList.contains('is-open')) {
        closeLineModal();
      }
      if (event.key === 'ArrowRight' && lineModal?.classList.contains('is-open')) {
        event.preventDefault();
        updateLineModal(lineModalState.index + 1);
      }
      if (event.key === 'ArrowLeft' && lineModal?.classList.contains('is-open')) {
        event.preventDefault();
        updateLineModal(lineModalState.index - 1);
      }
    });

    // ------------ EVENTS ------------
    document.getElementById('username').addEventListener('keydown', e => {
      if (e.key === 'Enter') runAnalysis();
    });
    document.getElementById('analyzeBtn').addEventListener('click', runAnalysis);
    document.getElementById('modeOpponent').addEventListener('click', () => setAnalysisMode(ANALYSIS_MODES.opponent));
    document.getElementById('modeSelf').addEventListener('click', () => setAnalysisMode(ANALYSIS_MODES.self));
    document.getElementById('gmMode').addEventListener('change', updateGmOptionVisibility);
    document.getElementById('engineEnabled').addEventListener('change', updateEngineControlsAvailability);
    updateGmOptionVisibility();
    updateEngineControlsAvailability();
    setAnalysisMode(state.mode);
    document.getElementById('exportJsonBtn').addEventListener('click', () => exportPrep('json'));
    document.getElementById('exportMarkdownBtn').addEventListener('click', () => exportPrep('markdown'));
    document.getElementById('exportPdfBtn').addEventListener('click', () => exportPrep('pdf'));
  </script>

</body>

</html>
