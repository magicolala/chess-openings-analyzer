<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analyseur d'Ouvertures Chess.com</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/cm-chessboard@7.11.0/assets/chessboard.css"
  />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 10px;
      font-size: 2.5em;
    }

    .subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 30px;
    }

    .search-section {
      display: flex;
      gap: 10px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }

    input[type="text"] {
      flex: 1;
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 16px;
      transition: border-color 0.3s;
      min-width: 200px;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
    }

    button {
      padding: 15px 30px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .loading {
      text-align: center;
      padding: 20px;
      font-size: 18px;
      color: #667eea;
    }

    .error {
      background: #fee;
      color: #c00;
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
    }

    .player-info {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 30px;
    }

    .player-info h2 {
      color: #333;
      margin-bottom: 10px;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }

    .stat-card {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .stat-label {
      color: #666;
      font-size: 14px;
    }

    .stat-value {
      color: #333;
      font-size: 24px;
      font-weight: bold;
      margin-top: 5px;
    }

    .openings-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-top: 30px;
    }

    @media (max-width: 768px) {
      .openings-section {
        grid-template-columns: 1fr;
      }
    }

    .openings-card {
      background: #f8f9fa;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
    }

    .openings-card h3 {
      margin-bottom: 20px;
      color: #333;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .chess-piece {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }

    .white-piece {
      background: white;
      border: 2px solid #333;
    }

    .black-piece {
      background: #333;
      color: white;
    }

    .opening-item {
      background: white;
      padding: 15px;
      margin-bottom: 10px;
      border-radius: 8px;
      transition: transform 0.2s, box-shadow 0.2s;
      cursor: pointer;
    }

    .opening-item:hover {
      transform: translateX(5px);
      box-shadow: 0 3px 15px rgba(0, 0, 0, 0.1);
    }

    .opening-name {
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }

    .trap-name {
      color: #c00;
      font-weight: bold;
    }

    .trap-name::before {
      content: '‚ò†Ô∏è';
      margin-right: 5px;
    }

    .opening-stats {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .opening-stat {
      font-size: 14px;
      color: #666;
    }

    .win-rate {
      color: #28a745;
      font-weight: bold;
    }

    .draw-rate {
      color: #ffc107;
      font-weight: bold;
    }

    .loss-rate {
      color: #dc3545;
      font-weight: bold;
    }

    .progress-bar {
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      margin-top: 8px;
      overflow: hidden;
      display: flex;
    }

    .progress-win {
      background: #28a745;
      height: 100%;
      transition: width 0.3s;
    }

    .progress-draw {
      background: #ffc107;
      height: 100%;
      transition: width 0.3s;
    }

    .progress-loss {
      background: #dc3545;
      height: 100%;
      transition: width 0.3s;
    }

    .no-data {
      text-align: center;
      color: #999;
      padding: 20px;
      font-style: italic;
    }

    .trap-name {
      color: #b10000;
      font-weight: 700;
    }

    .trap-recos {
      margin-top: .4rem;
      border-left: 3px solid #b10000;
      padding-left: .6rem;
    }

    .trap-reco {
      margin: .25rem 0;
      font-size: .92rem;
    }

    .trap-reco-seq {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      opacity: .9;
    }

    .trap-reco-tip {
      opacity: .85;
    }
    .line-block {
      margin-top: 12px;
    }
    .line-label {
      font-weight: 600;
      color: #444;
      margin-bottom: 4px;
    }
    .line-preview {
      display: block;
      width: 100%;
      text-align: left;
      background: #eef2ff;
      border: none;
      border-radius: 8px;
      padding: 10px 12px;
      font-size: .95rem;
      cursor: pointer;
      white-space: normal;
      line-height: 1.5;
      transition: background .2s, transform .2s;
    }
    .line-preview:hover {
      background: #e0e7ff;
      transform: translateX(2px);
    }
    .line-preview:focus {
      outline: 2px solid #667eea;
      outline-offset: 2px;
    }
    .line-meta {
      margin-top: 6px;
      font-size: .85rem;
      color: #555;
    }
    .observed-traps {
      margin-top: 16px;
      padding: 12px;
      border-radius: 12px;
      background: #fff5f5;
      border: 1px solid #f5c2c7;
    }
    .observed-traps-header {
      font-weight: 700;
      color: #b10000;
      margin-bottom: 8px;
    }
    .observed-trap + .observed-trap {
      margin-top: 12px;
    }
    .trap-detected-name {
      font-weight: 600;
      color: #b10000;
      margin-bottom: 6px;
    }
    .trap-reco-line {
      margin-top: 6px;
    }
    .lichess-advice {
      margin-top: .5rem;
      border-left: 3px solid #667eea;
      padding-left: .6rem;
      font-size: .9rem;
    }
    .lichess-advice summary {
      cursor: pointer;
      font-weight: 600;
      padding: .2rem 0;
    }
    .lichess-advice ul {
      list-style-type: none;
      padding-left: .2rem;
      margin-top: .4rem;
    }
    .lichess-advice li {
      margin-bottom: .3rem;
      display: flex;
      flex-direction: column;
      gap: .25rem;
    }
    #boardPreview {
      position: absolute;
      display: none;
      z-index: 1000;
      background: white;
      border-radius: 12px;
      box-shadow: 0 15px 45px rgba(0, 0, 0, 0.25);
      padding: 12px;
      pointer-events: none;
      width: 240px;
    }
    #boardPreview .board-preview-board {
      width: 216px;
      height: 216px;
    }
    .board-preview-caption {
      margin-top: 8px;
      font-size: .8rem;
      color: #444;
      line-height: 1.35;
      word-break: break-word;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>‚ôüÔ∏è Analyseur d'Ouvertures Chess.com</h1>
    <p class="subtitle">D√©couvrez les ouvertures pr√©f√©r√©es de n'importe quel joueur</p>

    <div class="search-section">
      <input type="text" id="username" placeholder="Entrez le pseudo Chess.com (ex: hikaru)" />
      <button id="analyzeBtn">Analyser</button>
    </div>

    <div id="loading" class="loading" style="display: none;">
      ‚è≥ Chargement des parties en cours...
    </div>

    <div id="error" class="error" style="display: none;"></div>

    <div id="playerInfo" style="display: none;"></div>

    <div id="openingsSection" class="openings-section" style="display: none;">
      <div class="openings-card">
        <h3>
          <span class="chess-piece white-piece">‚ôî</span>
          Ouvertures avec les Blancs
        </h3>
        <div id="whiteOpenings"></div>
      </div>

      <div class="openings-card">
        <h3>
          <span class="chess-piece black-piece">‚ôö</span>
          Ouvertures avec les Noirs
        </h3>
        <div id="blackOpenings"></div>
      </div>
    </div>
  </div>

  <div id="boardPreview">
    <div
      id="boardPreviewBoard"
      class="board-preview-board"
      aria-hidden="true"
    ></div>
    <div class="board-preview-caption" id="boardPreviewCaption"></div>
  </div>

  <script type="module">
    import { Chess } from 'https://esm.sh/chess.js';
    import {
      Chessboard,
      BORDER_TYPE,
      FEN,
    } from 'https://unpkg.com/cm-chessboard@7.11.0/src/Chessboard.js';
    import { adviseFromLichess, mapSpeed, pickLichessBucket } from './lichess-explorer.js';
    import { registerEcoOpenings } from './eco-pack-xl.js';
    import { TrapEngine, TRAP_PACK } from './trap-engine.js';

    // ------------ ECO MAP DE BASE + PACK XL ------------
    const ECO_OPENINGS = new Map([
      [['e4', 'e5', 'Nf3', 'Nc6', 'Bb5'].join(' '), 'Espagnole (Ruy Lopez)'],
      [['e4', 'e5', 'Nf3', 'Nc6', 'Bc4'].join(' '), 'Italienne (Giuoco Piano)'],
      [['e4', 'e5', 'Nf3', 'Nf6'].join(' '), 'D√©fense Petrov'],
      [['e4', 'e5', 'Nf3', 'Nc6', 'd4'].join(' '), '√âcossaise'],
      [['e4', 'e5', 'Nf3', 'f5'].join(' '), 'Gambit Letton'],
      [['e4', 'e5', 'f4'].join(' '), 'Gambit du Roi'],
      [['e4', 'e5', 'Nc3'].join(' '), 'Viennoise'],
      [['e4', 'e5', 'Bc4'].join(' '), 'Partie du Fou'],

      // Sicilienne
      [['e4', 'c5'].join(' '), 'D√©fense Sicilienne'],
      [['e4', 'c5', 'Nf3', 'd6'].join(' '), 'Sicilienne Dragon (setup)'],
      [['e4', 'c5', 'Nf3', 'Nc6'].join(' '), 'Sicilienne Classique'],
      [['e4', 'c5', 'Nf3', 'e6'].join(' '), 'Sicilienne Variante Fran√ßaise'],
      [['e4', 'c5', 'Nf3', 'Nf6'].join(' '), 'Sicilienne Nimzowitsch'],
      [['e4', 'c5', 'c3'].join(' '), 'Sicilienne Alapin'],

      // Fran√ßaise
      [['e4', 'e6'].join(' '), 'D√©fense Fran√ßaise'],
      [['e4', 'e6', 'd4', 'd5'].join(' '), 'Fran√ßaise (Var. principale)'],
      [['e4', 'e6', 'd4', 'd5', 'e5'].join(' '), 'Fran√ßaise Avance'],
      [['e4', 'e6', 'd4', 'd5', 'Nc3'].join(' '), 'Fran√ßaise Classique'],
      [['e4', 'e6', 'd4', 'd5', 'exd5'].join(' '), 'Fran√ßaise √âchange'],

      // Caro-Kann
      [['e4', 'c6'].join(' '), 'D√©fense Caro-Kann'],
      [['e4', 'c6', 'd4', 'd5'].join(' '), 'Caro-Kann (Var. principale)'],
      [['e4', 'c6', 'd4', 'd5', 'Nc3'].join(' '), 'Caro-Kann Classique'],
      [['e4', 'c6', 'd4', 'd5', 'e5'].join(' '), 'Caro-Kann Avance'],

      // Autres vs e4
      [['e4', 'd5'].join(' '), 'D√©fense Scandinave'],
      [['e4', 'd6'].join(' '), 'D√©fense Pirc'],
      [['e4', 'Nf6'].join(' '), 'D√©fense Alekhine'],
      [['e4', 'g6'].join(' '), 'D√©fense Moderne'],
      [['e4', 'Nc6'].join(' '), 'D√©fense Nimzowitsch'],
      [['e4', 'a6'].join(' '), 'D√©fense St. George'],
      [['e4', 'b6'].join(' '), 'D√©fense Owen'],

      // d4
      [['d4', 'd5'].join(' '), 'Partie du Pion Dame'],
      [['d4', 'd5', 'c4'].join(' '), 'Gambit Dame'],
      [['d4', 'd5', 'c4', 'dxc4'].join(' '), 'Gambit Dame Accept√©'],
      [['d4', 'd5', 'c4', 'e6'].join(' '), 'Gambit Dame Refus√©'],
      [['d4', 'd5', 'c4', 'c6'].join(' '), 'D√©fense Slave'],
      [['d4', 'd5', 'Nf3'].join(' '), 'Syst√®me de Londres (ordre flexible)'],
      [['d4', 'd5', 'Bf4'].join(' '), 'Syst√®me de Londres (avec Bf4)'],

      // Indiennes
      [['d4', 'Nf6'].join(' '), 'D√©fenses Indiennes'],
      [['d4', 'Nf6', 'c4', 'e6'].join(' '), 'Nimzo/Ouest-Indienne (set-up)'],
      [['d4', 'Nf6', 'c4', 'g6'].join(' '), 'Est-Indienne (set-up)'],
      [['d4', 'Nf6', 'c4', 'e6', 'Nc3', 'Bb4'].join(' '), 'D√©fense Nimzo-Indienne'],
      [['d4', 'Nf6', 'c4', 'e6', 'Nf3', 'b6'].join(' '), 'D√©fense Ouest-Indienne'],
      [['d4', 'Nf6', 'c4', 'c5'].join(' '), 'D√©fense Benoni Moderne'],
      [['d4', 'Nf6', 'Nf3', 'g6'].join(' '), 'Est-Indienne (avec Nf3)'],

      // Autres d4
      [['d4', 'f5'].join(' '), 'D√©fense Hollandaise'],
      [['d4', 'e6'].join(' '), 'Fran√ßaise par transposition'],
      [['d4', 'g6'].join(' '), 'Moderne vs d4'],
      [['d4', 'd6'].join(' '), 'Old Indian'],
      [['d4', 'c5'].join(' '), 'Benoni Ancienne'],

      // Anglaise, R√©ti et co
      [['c4'].join(' '), 'Ouverture Anglaise'],
      [['c4', 'e5'].join(' '), 'Anglaise Sym√©trique (r√©ponse e5)'],
      [['c4', 'c5'].join(' '), 'Anglaise Sym√©trique (Sicilienne invers√©e)'],
      [['c4', 'Nf6'].join(' '), 'Anglaise avec Nf6'],
      [['c4', 'e6'].join(' '), 'Anglaise avec e6'],

      [['Nf3'].join(' '), 'Ouverture R√©ti'],
      [['Nf3', 'd5'].join(' '), 'R√©ti avec d5'],
      [['Nf3', 'Nf6'].join(' '), 'R√©ti Sym√©trique'],
      [['Nf3', 'd5', 'c4'].join(' '), 'Gambit R√©ti'],

      [['f4'].join(' '), 'Ouverture Bird'],
      [['b3'].join(' '), 'Ouverture Larsen'],
      [['g3'].join(' '), 'Ouverture Benko (fianchetto)'],
      [['Nc3'].join(' '), 'Ouverture Van Geet'],
      [['e3'].join(' '), "Ouverture Van't Kruijs"],
      [['b4'].join(' '), 'Ouverture Polonaise'],
    ]);

    // Injecte le pack XL + pi√®ges
    registerEcoOpenings(ECO_OPENINGS, { includeTraps: true });

    const trapEngine = new TrapEngine();
    trapEngine.register(TRAP_PACK);

    // ------------ FALLBACK 1er COUP ------------
    const FIRST_MOVE_FALLBACK = new Map([
      ['e4', 'Ouvertures ouvertes (1.e4)'],
      ['d4', 'Ouvertures ferm√©es (1.d4)'],
      ['c4', 'Ouverture Anglaise'],
      ['Nf3', 'Ouverture R√©ti'],
      ['f4', 'Ouverture Bird'],
      ['b3', 'Ouverture Larsen'],
      ['g3', 'Fianchetto (type R√©ti/Anglaise)'],
      ['Nc3', 'Ouverture Van Geet'],
      ['e3', "Ouverture Van't Kruijs"],
      ['b4', 'Ouverture Polonaise'],
    ]);

    // ------------ UTILS G√âN√âRAUX ------------
    const FR = new Intl.DisplayNames(['fr'], { type: 'region' });

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, s =>
        ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[s])
      );
    }

    function parsePgnTags(pgn) {
      const tags = {};
      const re = /\[(\w+)\s+"([^"]*)"\]/g;
      let m;
      while ((m = re.exec(pgn)) !== null) tags[m[1]] = m[2];
      return tags;
    }

    function getCountryNameFromUrl(url) {
      try {
        if (!url) return 'N/A';
        const code = url.split('/').pop();
        return code ? (FR.of(code) || code) : 'N/A';
      } catch {
        return 'N/A';
      }
    }

    function tokensToLineInfo(tokens, { limit = null } = {}) {
      if (!Array.isArray(tokens) || !tokens.length) {
        return { line: '', fen: '', moveCount: 0 };
      }

      const trimmed = limit ? tokens.slice(0, limit) : [...tokens];
      const chess = new Chess();
      const parts = [];
      let moveNumber = 1;
      let turn = 'white';

      for (const move of trimmed) {
        if (!move) continue;
        try {
          chess.move(move);
        } catch {
          break;
        }
        if (turn === 'white') {
          parts.push(`${moveNumber}. ${move}`);
          turn = 'black';
        } else {
          const lastIndex = parts.length - 1;
          if (lastIndex >= 0) parts[lastIndex] += ` ${move}`;
          moveNumber++;
          turn = 'white';
        }
      }

      const history = chess.history();
      const fen = history.length ? chess.fen() : '';
      const fallback = trimmed.filter(Boolean).join(' ');

      return {
        line: parts.join(' ') || fallback,
        fen,
        moveCount: history.length,
      };
    }

    function buildLinePreview(tokens, { limit = null, extraClass = '' } = {}) {
      const info = tokensToLineInfo(tokens, { limit });
      if (!info.line) return { html: '', info };
      const fenAttr = info.fen ? ` data-fen="${escapeHtml(info.fen)}"` : '';
      const classAttr = extraClass ? ` ${extraClass}` : '';
      const html = `
        <button type="button" class="line-preview${classAttr}"${fenAttr} data-line="${escapeHtml(info.line)}">
          ${escapeHtml(info.line)}
        </button>
      `;
      return { html, info };
    }

    function renderMainLine(tokens) {
      if (!tokens || !tokens.length) return '';
      const { html } = buildLinePreview(tokens, { limit: 14 });
      if (!html) return '';
      return `
        <div class="line-block">
          <div class="line-label">Ligne principale</div>
          ${html}
        </div>
      `;
    }

    function renderObservedTraps(traps = []) {
      if (!Array.isArray(traps) || !traps.length) return '';
      const seen = new Set();
      const items = [];
      for (const trap of traps) {
        if (!trap?.id || seen.has(trap.id)) continue;
        seen.add(trap.id);
        const seq = Array.isArray(trap.seq) ? trap.seq : [];
        const { html } = buildLinePreview(seq);
        if (!html) continue;
        const advice = trap.advice ? `<div class="line-meta">${escapeHtml(trap.advice)}</div>` : '';
        items.push(`
          <div class="observed-trap">
            <div class="trap-detected-name">üí• ${escapeHtml(trap.name)}</div>
            ${html}
            ${advice}
          </div>
        `);
      }
      if (!items.length) return '';
      return `
        <div class="observed-traps">
          <div class="observed-traps-header">Pi√®ges rep√©r√©s dans vos parties</div>
          ${items.join('')}
        </div>
      `;
    }

    function renderTrapRecommendations(recs = []) {
      if (!Array.isArray(recs) || !recs.length) return '';
      const chunks = recs.map(rec => {
        const seq = Array.isArray(rec.seq) ? rec.seq : [];
        const { html } = buildLinePreview(seq, { extraClass: 'trap-reco-line' });
        if (!html) return '';
        return `
          <div class="trap-reco">
            <div class="trap-reco-name">üí£ ${escapeHtml(rec.name)}</div>
            ${html}
            <div class="trap-reco-tip">üí° ${escapeHtml(rec.advice)}</div>
          </div>
        `;
      }).filter(Boolean);
      if (!chunks.length) return '';
      return `<div class="trap-recos">${chunks.join('')}</div>`;
    }

    function withTimeout(ms, signal) {
      const ctrl = new AbortController();
      const onAbort = () => ctrl.abort();
      if (signal) signal.addEventListener('abort', onAbort, { once: true });
      const t = setTimeout(() => ctrl.abort(), ms);
      const cleanup = () => clearTimeout(t);
      return { signal: ctrl.signal, cleanup };
    }

    // ------------ PGN ‚Üí TOKENS ------------
    function loadPgnCompat(chessInstance, pgn, options) {
      const loader = typeof chessInstance.loadPgn === 'function'
        ? chessInstance.loadPgn
        : typeof chessInstance.load_pgn === 'function'
          ? chessInstance.load_pgn
          : null;
      if (!loader) throw new Error('No loadPgn function available on chess.js instance');
      return loader.call(chessInstance, pgn, options);
    }

    function normalizeToTokens(pgn) {
      if (!pgn || typeof pgn !== 'string') return [];

      try {
        const chess = new Chess();
        const loaded = loadPgnCompat(chess, pgn, { sloppy: true });
        if (loaded) {
          return chess.history({ verbose: true }).map(move =>
            (move?.san || '')
              .replace(/[+#]/g, '')
          );
        }
      } catch (err) {
        console.warn('Failed to parse PGN via chess.js', err);
      }

      let s = pgn
        .replace(/\{[^}]*\}/g, ' ')
        .replace(/;.*/g, ' ')
        .replace(/\([^)]*\)/g, ' ')
        .replace(/\$\d+/g, ' ');

      s = s.replace(/\b(1-0|0-1|1\/2-1\/2|\*)\b/g, ' ');
      s = s.replace(/\d+\.(\.\.)?/g, ' ');
      s = s.replace(/[+#]/g, '');
      s = s.replace(/\s+/g, ' ').trim();

      if (!s) return [];

      const tokens = s
        .split(' ')
        .filter(tok =>
          /^[O0]-O(-O)?$/.test(tok) ||
          /^[KQRNB]?[a-h]?[1-8]?x?[a-h][1-8](=[QRNB])?$/.test(tok) ||
          /^[a-h]x?[a-h][1-8](=[QRNB])?$/.test(tok) ||
          /^[a-h][1-8]$/.test(tok) ||
          /^[KQRNB][a-h][1-8]$/.test(tok)
        )
        .map(tok => tok.replace(/^0-0$/, 'O-O').replace(/^0-0-0$/, 'O-O-O'));

      return tokens;
    }

    // ------------ MATCHING OUVERTURE ------------
    function getOpeningName(tokens) {
      if (!tokens.length) return 'Ouverture inconnue';
      const MAX_PLIES = Math.min(tokens.length, 20);
      for (let plies = MAX_PLIES; plies >= 2; plies--) {
        const prefix = tokens.slice(0, plies).join(' ');
        if (ECO_OPENINGS.has(prefix)) return ECO_OPENINGS.get(prefix);
        for (const [pattern, name] of ECO_OPENINGS.entries()) {
          if (prefix === pattern || prefix.startsWith(pattern + ' ')) return name;
        }
      }
      const first = tokens[0];
      if (FIRST_MOVE_FALLBACK.has(first)) return FIRST_MOVE_FALLBACK.get(first);
      if (first === 'O-O' || first === 'O-O-O') return 'Ouverture avec roque rapide';
      return 'Ouverture inconnue';
    }

    // ------------ FETCH & ANALYSE ------------
    const MONTHS_TO_CHECK = 3;
    const FETCH_TIMEOUT_MS = 10000;

    // Helper: c√¥t√© au trait apr√®s N demi-coups
    function sideToMoveAfter(tokens) {
      // trait blanc au d√©but; si nb de demi-coups est pair -> trait aux blancs, sinon noirs
      return (tokens.length % 2 === 0) ? 'white' : 'black';
    }

    // Choix cadence par d√©faut en fonction des stats Chess.com
    function pickSpeedFromChesscom(statsData) {
      // prend la meilleure cadence dispo, sinon 'blitz'
      const order = ['chess_blitz', 'chess_rapid', 'chess_bullet'];
      for (const k of order) {
        if (statsData?.[k]?.last?.rating) {
          const map = { chess_blitz: 'blitz', chess_rapid: 'rapid', chess_bullet: 'bullet' };
          return map[k];
        }
      }
      return 'blitz';
    }

    // Enrichit un bloc d‚Äôouvertures avec suggestions Lichess
    async function enrichWithLichessSuggestions(openingsObject, playerElo, chesscomStats) {
      const entries = Object.entries(openingsObject);
      const speed = pickSpeedFromChesscom(chesscomStats);

      // On ne va pas spamer l‚ÄôAPI: on prend les 8 openings les plus fr√©quentes
      const topEntries = entries.sort((a, b) => b[1].count - a[1].count).slice(0, 8);

      const promises = topEntries.map(async ([name, stats]) => {
        // On stocke le dernier pgn tokens qui a produit ce name pour lancer la requ√™te
        const sampleTokens = stats._sampleTokens || null;
        if (!sampleTokens) return;

        try {
          const trait = sideToMoveAfter(sampleTokens);
          const out = await adviseFromLichess({
            tokens: sampleTokens,
            sideToMove: trait,
            playerRating: playerElo,
            // offset si tu veux compenser la diff Chess.com/Lichess; 0 par d√©faut. Mets +100 si tu veux.
            ratingOffset: 0,
            speed,
            top: 5
          });
          stats._lichess = out; // on attache pour l‚ÄôUI
        } catch (e) {
          console.warn('Explorer fail for', name, e);
        }
      });

      // Use Promise.allSettled to prevent unhandled rejections
      await Promise.allSettled(promises);
    }

    async function analyzePlayer() {
      const usernameInput = document.getElementById('username');
      const btn = document.getElementById('analyzeBtn');
      const username = usernameInput.value.trim();
      if (!username) return showError('Veuillez entrer un pseudo Chess.com');

      hideError();
      showLoading();
      hideResults();
      btn.disabled = true;

      try {
        // Player + stats en parall√®le
        const base = `https://api.chess.com/pub/player/${encodeURIComponent(username)}`;
        const { signal, cleanup } = withTimeout(FETCH_TIMEOUT_MS);
        const [playerRes, statsRes] = await Promise.all([
          fetch(base, { signal }),
          fetch(`${base}/stats`, { signal }),
        ]);
        cleanup();

        if (!playerRes.ok) throw new Error('Joueur non trouv√©');
        const playerData = await playerRes.json();
        const statsData = statsRes.ok ? await statsRes.json() : {};

        // Archives des N derniers mois en parall√®le
        const now = new Date();
        const months = Array.from({ length: MONTHS_TO_CHECK }, (_, i) => {
          const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
          return { y: d.getFullYear(), m: String(d.getMonth() + 1).padStart(2, '0') };
        });

        const monthFetches = months.map(({ y, m }) => {
          const { signal, cleanup } = withTimeout(FETCH_TIMEOUT_MS);
          return fetch(`https://api.chess.com/pub/player/${encodeURIComponent(username)}/games/${y}/${m}`, { signal })
            .then(r => (cleanup(), r.ok ? r.json() : { games: [] }))
            .catch(() => ({ games: [] }));
        });

        const monthPayloads = await Promise.allSettled(monthFetches);
        const recentGames = monthPayloads.flatMap(res => res.status === 'fulfilled' ? (res.value.games || []) : []);

        if (!recentGames.length) throw new Error('Aucune partie r√©cente trouv√©e');

        // Filtrer parties standard (pas chess960 etc.)
        const games = recentGames.filter(g => g.rules ? g.rules === 'chess' : true);

        // Stats par couleurs
        const whiteOpenings = {};
        const blackOpenings = {};

        for (const game of games) {
          if (!game.pgn) continue;

          const youAreWhite = game.white && game.white.username && String(game.white.username).toLowerCase() === username.toLowerCase();

          // R√©sultat c√¥t√© "toi"
          let result = 'draw';
          if (game.white?.result === 'win') result = youAreWhite ? 'win' : 'loss';
          else if (game.black?.result === 'win') result = youAreWhite ? 'loss' : 'win';

          const tokens = normalizeToTokens(game.pgn).slice(0, 12);
          const openingName = getOpeningName(tokens);
          const targetOpenings = youAreWhite ? whiteOpenings : blackOpenings;

          if (!targetOpenings[openingName]) {
            targetOpenings[openingName] = { count: 0, wins: 0, draws: 0, losses: 0, _sampleTokens: tokens, traps: [] };
          } else if (!targetOpenings[openingName]._sampleTokens && tokens?.length) {
            targetOpenings[openingName]._sampleTokens = tokens;
          }

          const bucket = targetOpenings[openingName];
          bucket.count++;
          if (result === 'win') bucket.wins++;
          else if (result === 'draw') bucket.draws++;
          else bucket.losses++;

          // Match des pi√®ges vus dans la partie
          const yourSide = youAreWhite ? 'white' : 'black';
          const trapScan = trapEngine.matchPgn(game.pgn, { openingLabel: openingName, side: yourSide, maxPlies: 24 });
          if (trapScan.hits.length) {
            bucket.traps.push(...trapScan.hits.slice(0, 2));
            bucket.isTrap = true;
          }
        }

        // R√©cup Elo c√¥t√© Chess.com pour approx du bucket
        const userElo = Math.max(
          statsData?.chess_blitz?.last?.rating || 0,
          statsData?.chess_rapid?.last?.rating || 0,
          statsData?.chess_bullet?.last?.rating || 0
        ) || 1500;

        await enrichWithLichessSuggestions(whiteOpenings, userElo, statsData);
        await enrichWithLichessSuggestions(blackOpenings, userElo, statsData);

        displayPlayerInfo(playerData, statsData);
        displayOpenings(whiteOpenings, blackOpenings);

      } catch (err) {
        showError(err.message || 'Erreur inconnue');
      } finally {
        hideLoading();
        btn.disabled = false;
      }
    }

    // ------------ UI ------------
    function renderLichessAdvice(stats) {
      if (!stats._lichess?.suggestions?.length) return '';
      const o = stats._lichess;
      const tag = o.openingName ? ` (${o.openingName}${o.eco ? ' ‚Äì ' + o.eco : ''})` : '';
      const baseTokens = Array.isArray(stats._sampleTokens) ? stats._sampleTokens : [];
      const items = o.suggestions.slice(0, 3).map(s => {
        const tokens = [...baseTokens, s.san].filter(Boolean);
        const { html, info } = buildLinePreview(tokens, { limit: baseTokens.length + 1 });
        const fallbackText = info.line || s.san;
        const button = html || `
          <button type="button" class="line-preview" data-line="${escapeHtml(fallbackText)}">
            ${escapeHtml(fallbackText)}
          </button>
        `;
        const score = Math.round((s.sideExpectedScore || 0) * 100);
        return `
          <li>
            ${button}
            <div class="line-meta">Score attendu ${score}% ¬∑ ${s.total} parties</div>
          </li>
        `;
      }).join('');
      return `
        <details class="lichess-advice">
          <summary>Coups recommand√©s (Lichess)${tag}</summary>
          <ul>${items}</ul>
        </details>
      `;
    }

    function displayPlayerInfo(playerData, statsData) {
      const playerInfoDiv = document.getElementById('playerInfo');
      const rapid = statsData?.chess_rapid?.last?.rating ?? 'N/A';
      const blitz = statsData?.chess_blitz?.last?.rating ?? 'N/A';
      const bullet = statsData?.chess_bullet?.last?.rating ?? 'N/A';
      const country = getCountryNameFromUrl(playerData.country);

      playerInfoDiv.innerHTML = `
            <div class="player-info">
              <h2>${escapeHtml(playerData.username || '')}</h2>
              <div class="stats">
                <div class="stat-card"><div class="stat-label">Rapid</div><div class="stat-value">${rapid}</div></div>
                <div class="stat-card"><div class="stat-label">Blitz</div><div class="stat-value">${blitz}</div></div>
                <div class="stat-card"><div class="stat-label">Bullet</div><div class="stat-value">${bullet}</div></div>
                <div class="stat-card"><div class="stat-label">Pays</div><div class="stat-value">${escapeHtml(country)}</div></div>
              </div>
            </div>
          `;
      playerInfoDiv.style.display = 'block';
    }

    function formatOpeningRow(name, stats, extraHtml = '') {
      const winRate = stats.count ? ((stats.wins / stats.count) * 100).toFixed(1) : '0.0';
      const drawRate = stats.count ? ((stats.draws / stats.count) * 100).toFixed(1) : '0.0';
      const lossRate = stats.count ? ((stats.losses / stats.count) * 100).toFixed(1) : '0.0';
      const safeName = escapeHtml(name);
      const labelHtml = stats.isTrap ? `<span class="trap-name">${safeName}</span>` : safeName;

      return `
            <div class="opening-item">
              <div class="opening-name">${labelHtml}</div>
              <div class="opening-stats">
                <span class="opening-stat">üìä ${stats.count} parties</span>
                <span class="opening-stat win-rate">‚úì ${winRate}%</span>
                <span class="opening-stat draw-rate">= ${drawRate}%</span>
                <span class="opening-stat loss-rate">‚úó ${lossRate}%</span>
              </div>
              <div class="progress-bar">
                <div class="progress-win" style="width:${winRate}%"></div>
                <div class="progress-draw" style="width:${drawRate}%"></div>
                <div class="progress-loss" style="width:${lossRate}%"></div>
              </div>
              ${extraHtml}
            </div>
          `;
    }

    function buildOpeningSections(name, stats, side) {
      const sections = [];
      const mainLine = renderMainLine(stats._sampleTokens || []);
      if (mainLine) sections.push(mainLine);

      const observed = renderObservedTraps(stats.traps || []);
      if (observed) sections.push(observed);

      const recs = trapEngine.recommendByOpening(name, side, 3);
      const recsHtml = renderTrapRecommendations(recs);
      if (recsHtml) sections.push(recsHtml);

      const lichessHtml = renderLichessAdvice(stats);
      if (lichessHtml) sections.push(lichessHtml);

      return sections.join('');
    }

    function displayOpenings(whiteOpenings, blackOpenings) {
      const whiteDiv = document.getElementById('whiteOpenings');
      const blackDiv = document.getElementById('blackOpenings');

      const sortedWhite = Object.entries(whiteOpenings).sort((a, b) => b[1].count - a[1].count);
      const sortedBlack = Object.entries(blackOpenings).sort((a, b) => b[1].count - a[1].count);

      whiteDiv.innerHTML = sortedWhite.length
        ? sortedWhite.slice(0, 10).map(([name, stats]) => {
          const sections = buildOpeningSections(name, stats, 'white');
          return formatOpeningRow(name, stats, sections);
        }).join('')
        : '<div class="no-data">Aucune donn√©e disponible</div>';

      blackDiv.innerHTML = sortedBlack.length
        ? sortedBlack.slice(0, 10).map(([name, stats]) => {
          const sections = buildOpeningSections(name, stats, 'black');
          return formatOpeningRow(name, stats, sections);
        }).join('')
        : '<div class="no-data">Aucune donn√©e disponible</div>';

      document.getElementById('openingsSection').style.display = 'grid';
    }

    function showLoading() {
      document.getElementById('loading').style.display = 'block';
    }
    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }
    function showError(message) {
      const errorDiv = document.getElementById('error');
      errorDiv.textContent = `‚ùå Erreur : ${message}`;
      errorDiv.style.display = 'block';
    }
    function hideError() {
      document.getElementById('error').style.display = 'none';
    }
    function hideResults() {
      document.getElementById('playerInfo').style.display = 'none';
      document.getElementById('openingsSection').style.display = 'none';
      pinnedAnchor = null;
      hideBoardPreview();
    }

    // ------------ BOARD PREVIEW ------------
    const boardPreview = document.getElementById('boardPreview');
    const boardPreviewBoardEl = document.getElementById('boardPreviewBoard');
    const boardPreviewCaption = document.getElementById('boardPreviewCaption');
    const boardPreviewChessboard = boardPreviewBoardEl
      ? new Chessboard(boardPreviewBoardEl, {
          assetsUrl: 'https://unpkg.com/cm-chessboard@7.11.0/assets/',
          style: {
            showCoordinates: false,
            borderType: BORDER_TYPE.none,
            animationDuration: 0,
          },
        })
      : null;
    if (boardPreviewChessboard) {
      boardPreviewChessboard.setPosition(FEN.empty).catch(() => {});
    }
    let pinnedAnchor = null;

    function updateBoardPreviewPosition(fen) {
      if (!boardPreviewChessboard) return;
      const targetFen = fen || FEN.empty;
      boardPreviewChessboard
        .setPosition(targetFen)
        .catch(err => {
          console.warn('Failed to set preview FEN', err);
          boardPreviewChessboard.setPosition(FEN.empty).catch(() => {});
        });
    }

    function positionBoardPreview(anchor) {
      const rect = anchor.getBoundingClientRect();
      const boardWidth = boardPreview.offsetWidth || 240;
      const boardHeight = boardPreview.offsetHeight || 260;
      let left = window.scrollX + rect.right + 12;
      let top = window.scrollY + rect.top;

      const viewportRight = window.scrollX + window.innerWidth;
      if (left + boardWidth > viewportRight - 16) {
        left = window.scrollX + rect.left - boardWidth - 12;
      }
      if (left < window.scrollX + 12) left = window.scrollX + 12;

      const viewportBottom = window.scrollY + window.innerHeight;
      if (top + boardHeight > viewportBottom - 16) {
        top = viewportBottom - boardHeight - 16;
      }
      if (top < window.scrollY + 12) top = window.scrollY + 12;

      boardPreview.style.left = `${left}px`;
      boardPreview.style.top = `${top}px`;
    }

    function showBoardPreview(anchor) {
      if (!anchor) return;
      const fen = anchor.dataset.fen || '';
      const line = anchor.dataset.line || '';
      updateBoardPreviewPosition(fen);
      boardPreviewCaption.textContent = line;
      boardPreview.style.display = 'block';
      positionBoardPreview(anchor);
    }

    function hideBoardPreview() {
      boardPreview.style.display = 'none';
    }

    document.body.addEventListener('mouseover', event => {
      const anchor = event.target.closest('.line-preview');
      if (!anchor) {
        if (!pinnedAnchor) hideBoardPreview();
        return;
      }
      if (pinnedAnchor) return;
      showBoardPreview(anchor);
    });

    document.body.addEventListener('click', event => {
      const anchor = event.target.closest('.line-preview');
      if (anchor) {
        if (pinnedAnchor === anchor) {
          pinnedAnchor = null;
          hideBoardPreview();
        } else {
          pinnedAnchor = anchor;
          showBoardPreview(anchor);
        }
      } else if (!event.target.closest('#boardPreview')) {
        pinnedAnchor = null;
        hideBoardPreview();
      }
    });

    document.body.addEventListener('focusin', event => {
      const anchor = event.target.closest('.line-preview');
      if (anchor) {
        pinnedAnchor = anchor;
        showBoardPreview(anchor);
      } else if (!event.target.closest('#boardPreview')) {
        pinnedAnchor = null;
        hideBoardPreview();
      }
    });

    window.addEventListener('scroll', () => {
      if (pinnedAnchor && boardPreview.style.display === 'block') {
        positionBoardPreview(pinnedAnchor);
      }
    });

    window.addEventListener('resize', () => {
      if (pinnedAnchor && boardPreview.style.display === 'block') {
        positionBoardPreview(pinnedAnchor);
      }
    });

    // ------------ EVENTS ------------
    document.getElementById('username').addEventListener('keydown', e => {
      if (e.key === 'Enter') analyzePlayer();
    });
    document.getElementById('analyzeBtn').addEventListener('click', analyzePlayer);
  </script>

</body>

</html>
